<!DOCTYPE html>
<html>
<head>
    <title>出題範囲全アイテム関係性グラフ - League of Legends Item Quiz</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .full-graph-container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .graph-controls {
            margin-bottom: 20px;
            text-align: center;
        }
        .graph-controls button {
            background: #0596aa;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        .graph-controls button:hover {
            background: #047a8a;
        }
        .d3-full-graph {
            width: 100%;
            height: 800px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 20px 0;
            background: #f8f9fa;
        }
        .graph-stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #0596aa;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid;
        }
        .back-link {
            display: inline-block;
            background: #0596aa;
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            margin-top: 20px;
        }
        .back-link:hover {
            background: #047a8a;
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid #ffc107;
        }
        .tooltip .item-name {
            font-weight: bold;
            font-size: 14px;
            color: #ffc107;
            margin-bottom: 6px;
        }
        .tooltip .item-price {
            color: #ffc107;
            font-weight: bold;
            margin-bottom: 6px;
        }
        .tooltip .item-description {
            margin-bottom: 8px;
            line-height: 1.4;
            color: #ccc;
        }
        .tooltip .item-stats {
            margin-top: 8px;
        }
        .tooltip .stat-line {
            margin: 2px 0;
            color: #88ff88;
        }
        .filter-controls {
            margin: 15px 0;
            text-align: center;
        }
        .filter-controls label {
            margin: 0 10px;
            font-weight: bold;
        }
        .filter-controls input[type="range"] {
            width: 200px;
            margin: 0 10px;
        }
    </style>
</head>
<body>
    <div class="full-graph-container">
        <h1>出題範囲全アイテム関係性グラフ</h1>
        
        <div class="graph-stats">
            <div class="stat-item">
                <div class="stat-number" id="total-items">167</div>
                <div class="stat-label">総アイテム数</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="total-edges">332</div>
                <div class="stat-label">関係性数</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="basic-items">17</div>
                <div class="stat-label">素材アイテム</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="intermediate-items">43</div>
                <div class="stat-label">中間アイテム</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="legendary-items">103</div>
                <div class="stat-label">レジェンダリー</div>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #d4edda; border-color: #28a745;"></div>
                <span>素材アイテム（子がいない）</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #cce7ff; border-color: #007bff;"></div>
                <span>中間アイテム（親も子もいる）</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #fff3cd; border-color: #ffc107;"></div>
                <span>レジェンダリーアイテム（親がいない）</span>
            </div>
        </div>
        
        <div class="graph-controls">
            <button onclick="resetLayout()">レイアウト リセット</button>
            <button onclick="zoomToFit()">全体表示</button>
            <button onclick="pauseSimulation()">アニメーション 停止/再開</button>
        </div>
        
        <div class="filter-controls">
            <label for="min-price">最低価格:</label>
            <input type="range" id="min-price" min="0" max="5000" value="0" step="100">
            <span id="min-price-value">0G</span>
            
            <label for="max-price">最高価格:</label>
            <input type="range" id="max-price" min="0" max="5000" value="5000" step="100">
            <span id="max-price-value">5000G</span>
            
            <button onclick="applyPriceFilter()">フィルター適用</button>
            <button onclick="clearFilter()">フィルター解除</button>
        </div>
        
        <div class="loading" id="loading">グラフデータを読み込み中...</div>
        
        <div id="d3-full-graph" class="d3-full-graph" style="display: none;"></div>
        
        <div style="margin-top: 30px;">
            <h3>使い方</h3>
            <ul>
                <li><strong>物理シミュレーション</strong>: D3.jsによる動的レイアウト</li>
                <li><strong>価格フィルター</strong>: 指定した価格帯のアイテムのみ表示</li>
                <li><strong>ズーム・パン</strong>: マウスホイールでズーム、ドラッグで移動</li>
                <li><strong>ノードドラッグ</strong>: ノードをドラッグして位置調整可能</li>
                <li><strong>アニメーション制御</strong>: 停止/再開ボタンでパフォーマンス調整</li>
            </ul>
            
            <h3>グラフの読み方</h3>
            <ul>
                <li><strong>ノード</strong>: 各アイテムを表示（画像付き）</li>
                <li><strong>エッジ</strong>: 素材関係（矢印は合成方向）</li>
                <li><strong>色分け</strong>: 関係性に基づく分類（素材・中間・レジェンダリー）</li>
                <li><strong>サイズ</strong>: アイテムの重要度（多く使われる素材ほど大きく表示）</li>
            </ul>
        </div>
        
        <a href="/" class="back-link">メインページに戻る</a>
        <a href="/quiz_a_algorithm" class="back-link">アルゴリズム解説に戻る</a>
    </div>

    <script>
        let fullGraphData = null;
        let simulation = null;
        let svg = null;
        let g = null;
        let nodes = null;
        let links = null;
        let filteredData = null;
        let isPaused = false;
        
        // 価格フィルターの値更新
        document.getElementById('min-price').addEventListener('input', function() {
            document.getElementById('min-price-value').textContent = this.value + 'G';
        });
        
        document.getElementById('max-price').addEventListener('input', function() {
            document.getElementById('max-price-value').textContent = this.value + 'G';
        });
        
        // グラフデータを読み込み
        async function loadGraphData() {
            try {
                const response = await fetch('/static/full_graph_data.json');
                fullGraphData = await response.json();
                
                // 統計情報を更新
                document.getElementById('total-items').textContent = fullGraphData.stats.total_items;
                document.getElementById('total-edges').textContent = fullGraphData.stats.edges;
                document.getElementById('basic-items').textContent = fullGraphData.stats.basic_items;
                document.getElementById('intermediate-items').textContent = fullGraphData.stats.intermediate_items;
                document.getElementById('legendary-items').textContent = fullGraphData.stats.legendary_items;
                
                document.getElementById('loading').style.display = 'none';
                initializeD3Graph();
                
            } catch (error) {
                console.error('グラフデータの読み込みに失敗:', error);
                document.getElementById('loading').textContent = 'データの読み込みに失敗しました。';
            }
        }
        
        function initializeD3Graph() {
            if (!fullGraphData) return;
            
            document.getElementById('d3-full-graph').style.display = 'block';
            
            // 既存のSVGを削除
            d3.select('#d3-full-graph').selectAll('*').remove();
            
            // コンテナのサイズを取得
            const container = document.getElementById('d3-full-graph');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // SVGを作成
            svg = d3.select('#d3-full-graph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // ズーム動作を追加
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // グラフコンテナ
            g = svg.append('g');
            
            // データをコピー
            filteredData = {
                nodes: fullGraphData.nodes.map(d => ({...d})),
                edges: fullGraphData.edges.map(d => ({...d}))
            };
            
            // 素材アイテムを正多角形に配置
            const basicItems = filteredData.nodes.filter(d => d.category === 'basic');
            const radius = Math.min(width, height) * 0.35;
            const centerX = width / 2;
            const centerY = height / 2;
            
            basicItems.forEach((d, i) => {
                const angle = (i / basicItems.length) * 2 * Math.PI;
                d.fx = centerX + radius * Math.cos(angle);
                d.fy = centerY + radius * Math.sin(angle);
            });
            
            // シミュレーションを初期化（重複防止強化）
            simulation = d3.forceSimulation(filteredData.nodes)
                .force('link', d3.forceLink(filteredData.edges).id(d => d.id).distance(100).strength(0.3))
                .force('charge', d3.forceManyBody().strength(-400))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(d => getNodeRadius(d) + 8).strength(1).iterations(3))
                .force('x', d3.forceX(width / 2).strength(0.1))
                .force('y', d3.forceY(height / 2).strength(0.1));
            
            // エッジを描画
            const linkGroup = g.append('g').attr('class', 'links');
            links = linkGroup.selectAll('line')
                .data(filteredData.edges)
                .join('line')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 1)
                .attr('marker-end', 'url(#arrowhead)');
            
            // 矢印マーカーを定義
            svg.append('defs').append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#ccc');
            
            // ノードグループを作成
            const nodeGroup = g.append('g').attr('class', 'nodes');
            
            // ノードを描画
            nodes = nodeGroup.selectAll('.node')
                .data(filteredData.nodes)
                .join('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // ホバー判定用の透明な大きな円（ノードサイズの1.5倍）
            nodes.append('circle')
                .attr('class', 'hover-area')
                .attr('r', d => getNodeRadius(d) * 1.5)
                .attr('fill', 'transparent')
                .attr('stroke', 'none')
                .style('cursor', 'pointer');
            
            // ノードのフレーム（円）
            nodes.append('circle')
                .attr('r', d => getNodeRadius(d))
                .attr('fill', 'none')
                .attr('stroke', d => getNodeColor(d).stroke)
                .attr('stroke-width', d => d.category === 'legendary' ? 4 : 3)
                .style('pointer-events', 'none');
            
            // アイテム画像
            nodes.append('image')
                .attr('href', d => `https://ddragon.leagueoflegends.com/cdn/{{ patch_version }}/img/item/${d.itemId}.png`)
                .attr('width', d => getNodeRadius(d) * 2)
                .attr('height', d => getNodeRadius(d) * 2)
                .attr('x', d => -getNodeRadius(d))
                .attr('y', d => -getNodeRadius(d))
                .style('clip-path', d => `circle(${getNodeRadius(d) - 2}px)`)
                .style('pointer-events', 'none');
            
            // テキストラベルを削除（画像のみで表示）
            
            // リッチツールチップの実装
            const tooltip = d3.select('body').append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
            
            nodes.on('mouseover', function(event, d) {
                showTooltip(event, d, tooltip);
            })
            .on('mousemove', function(event, d) {
                tooltip.style('left', (event.pageX + 10) + 'px')
                       .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', function(event, d) {
                tooltip.transition().duration(200).style('opacity', 0);
            });
            
            // シミュレーションの更新処理
            simulation.on('tick', () => {
                links
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                nodes
                    .attr('transform', d => `translate(${d.x},${d.y})`);
            });
        }
        
        function getNodeRadius(d) {
            switch(d.category) {
                case 'basic': return 15;
                case 'intermediate': return 20;
                case 'legendary': return 25;
                default: return 18;
            }
        }
        
        function getNodeColor(d) {
            switch(d.category) {
                case 'basic': return { stroke: '#28a745' };
                case 'intermediate': return { stroke: '#007bff' };
                case 'legendary': return { stroke: '#ffc107' };
                default: return { stroke: '#6c757d' };
            }
        }
        
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            // 素材アイテムは正多角形位置を維持
            if (d.category !== 'basic') {
                d.fx = null;
                d.fy = null;
            }
        }
        
        
        function applyPriceFilter() {
            const minPrice = parseInt(document.getElementById('min-price').value);
            const maxPrice = parseInt(document.getElementById('max-price').value);
            
            if (!fullGraphData || !nodes) return;
            
            // フィルターされたデータを作成
            const filteredNodes = fullGraphData.nodes.filter(d => d.price >= minPrice && d.price <= maxPrice);
            const filteredNodeIds = new Set(filteredNodes.map(d => d.id));
            const filteredEdges = fullGraphData.edges.filter(d => 
                filteredNodeIds.has(d.source) && filteredNodeIds.has(d.target)
            );
            
            // データを更新
            filteredData.nodes = filteredNodes.map(d => ({...d}));
            filteredData.edges = filteredEdges.map(d => ({...d}));
            
            // 素材アイテムを正多角形に配置
            const container = document.getElementById('d3-full-graph');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const basicItems = filteredData.nodes.filter(d => d.category === 'basic');
            const radius = Math.min(width, height) * 0.35;
            const centerX = width / 2;
            const centerY = height / 2;
            
            basicItems.forEach((d, i) => {
                const angle = (i / basicItems.length) * 2 * Math.PI;
                d.fx = centerX + radius * Math.cos(angle);
                d.fy = centerY + radius * Math.sin(angle);
            });
            
            // シミュレーションを再初期化
            simulation.nodes(filteredData.nodes);
            simulation.force('link').links(filteredData.edges);
            
            // DOMを更新
            links = links.data(filteredData.edges, d => d.source.id + '-' + d.target.id);
            links.exit().remove();
            links = links.enter().append('line')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 1)
                .attr('marker-end', 'url(#arrowhead)')
                .merge(links);
            
            nodes = nodes.data(filteredData.nodes, d => d.id);
            nodes.exit().remove();
            const nodeEnter = nodes.enter().append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // ホバー判定用の透明な大きな円
            nodeEnter.append('circle')
                .attr('class', 'hover-area')
                .attr('r', d => getNodeRadius(d) * 1.5)
                .attr('fill', 'transparent')
                .attr('stroke', 'none')
                .style('cursor', 'pointer');
            
            nodeEnter.append('circle')
                .attr('r', d => getNodeRadius(d))
                .attr('fill', 'none')
                .attr('stroke', d => getNodeColor(d).stroke)
                .attr('stroke-width', d => d.category === 'legendary' ? 4 : 3)
                .style('pointer-events', 'none');
            
            nodeEnter.append('image')
                .attr('href', d => `https://ddragon.leagueoflegends.com/cdn/{{ patch_version }}/img/item/${d.itemId}.png`)
                .attr('width', d => getNodeRadius(d) * 2)
                .attr('height', d => getNodeRadius(d) * 2)
                .attr('x', d => -getNodeRadius(d))
                .attr('y', d => -getNodeRadius(d))
                .style('clip-path', d => `circle(${getNodeRadius(d) - 2}px)`)
                .style('pointer-events', 'none');
            
            // テキストラベルを削除（画像のみで表示）
            
            nodes = nodeEnter.merge(nodes);
            
            // ホバーイベントを再設定
            nodes.on('mouseover', function(event, d) {
                showTooltip(event, d, tooltip);
            })
            .on('mousemove', function(event, d) {
                tooltip.style('left', (event.pageX + 10) + 'px')
                       .style('top', (event.pageY - 10) + 'px');
            })
            .on('mouseout', function(event, d) {
                tooltip.transition().duration(200).style('opacity', 0);
            });
            
            // シミュレーションを再開
            simulation.alpha(1).restart();
        }
        
        function clearFilter() {
            document.getElementById('min-price').value = 0;
            document.getElementById('max-price').value = 5000;
            document.getElementById('min-price-value').textContent = '0G';
            document.getElementById('max-price-value').textContent = '5000G';
            
            applyPriceFilter();
        }
        
        function resetLayout() {
            if (!simulation) return;
            
            // 素材アイテム以外の固定を解除
            filteredData.nodes.forEach(d => {
                if (d.category !== 'basic') {
                    d.fx = null;
                    d.fy = null;
                }
            });
            
            // 素材アイテムを正多角形に再配置
            const container = document.getElementById('d3-full-graph');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const basicItems = filteredData.nodes.filter(d => d.category === 'basic');
            const radius = Math.min(width, height) * 0.35;
            const centerX = width / 2;
            const centerY = height / 2;
            
            basicItems.forEach((d, i) => {
                const angle = (i / basicItems.length) * 2 * Math.PI;
                d.fx = centerX + radius * Math.cos(angle);
                d.fy = centerY + radius * Math.sin(angle);
            });
            
            // シミュレーションを再開
            simulation.alpha(1).restart();
        }
        
        function zoomToFit() {
            if (!svg || !g) return;
            
            const bounds = g.node().getBBox();
            const parent = svg.node().parentElement;
            const fullWidth = parent.clientWidth;
            const fullHeight = parent.clientHeight;
            
            const width = bounds.width;
            const height = bounds.height;
            
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;
            
            if (width == 0 || height == 0) return;
            
            const scale = 0.8 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
            
            svg.transition()
                .duration(750)
                .call(d3.zoom().transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
        }
        
        function pauseSimulation() {
            if (!simulation) return;
            
            if (isPaused) {
                simulation.restart();
                isPaused = false;
            } else {
                simulation.stop();
                isPaused = true;
            }
        }
        
        function showTooltip(event, d, tooltip) {
            // ステータス情報を整形
            let statsHtml = '';
            if (d.stats && Object.keys(d.stats).length > 0) {
                statsHtml = '<div class="item-stats">';
                for (const [stat, value] of Object.entries(d.stats)) {
                    const statName = getStatName(stat);
                    if (statName && value !== 0) {
                        const displayValue = value > 0 ? `+${value}` : `${value}`;
                        statsHtml += `<div class="stat-line">${displayValue} ${statName}</div>`;
                    }
                }
                statsHtml += '</div>';
            }
            
            // ツールチップの内容を作成
            const tooltipContent = `
                <div class="item-name">${d.label}</div>
                <div class="item-price">${d.price}G</div>
                ${d.description ? `<div class="item-description">${d.description}</div>` : ''}
                ${statsHtml}
            `;
            
            tooltip.html(tooltipContent)
                   .style('left', (event.pageX + 10) + 'px')
                   .style('top', (event.pageY - 10) + 'px')
                   .transition().duration(200).style('opacity', 1);
        }
        
        function getStatName(stat) {
            const statNames = {
                'FlatHPPoolMod': 'ヘルス',
                'FlatMPPoolMod': 'マナ', 
                'FlatArmorMod': '物理防御',
                'FlatSpellBlockMod': '魔法防御',
                'FlatPhysicalDamageMod': '攻撃力',
                'FlatMagicDamageMod': 'AP',
                'PercentAttackSpeedMod': '攻撃速度',
                'PercentMovementSpeedMod': '移動速度',
                'FlatCritChanceMod': 'クリティカル率',
                'FlatCritDamageMod': 'クリティカルダメージ',
                'PercentLifeStealMod': 'ライフスティール',
                'PercentSpellVampMod': 'スペルヴァンプ',
                'FlatHPRegenMod': 'ヘルス回復',
                'FlatMPRegenMod': 'マナ回復',
                'PercentHPRegenMod': 'ヘルス回復%',
                'PercentMPRegenMod': 'マナ回復%'
            };
            return statNames[stat] || stat;
        }
        
        // ページ読み込み時にデータを読み込み
        document.addEventListener('DOMContentLoaded', loadGraphData);
    </script>
</body>
</html>
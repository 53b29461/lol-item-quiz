<!DOCTYPE html>
<html>
<head>
    <title>出題範囲全アイテム関係性グラフ - League of Legends Item Quiz</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .full-graph-container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .graph-controls {
            margin-bottom: 20px;
            text-align: center;
        }
        .graph-controls button {
            background: #0596aa;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        .graph-controls button:hover {
            background: #047a8a;
        }
        .edge-length-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            padding: 15px;
            background: #f0f8ff;
            border-radius: 8px;
            border: 1px solid #b0d4f1;
        }
        .edge-length-control label {
            font-weight: bold;
            color: #2c3e50;
        }
        .edge-length-slider {
            width: 200px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        .edge-length-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0596aa;
            cursor: pointer;
        }
        .edge-length-value {
            font-weight: bold;
            color: #0596aa;
            min-width: 50px;
            text-align: center;
        }
        .reset-button {
            background: #6c757d !important;
            padding: 8px 16px !important;
            font-size: 12px !important;
        }
        .reset-button:hover {
            background: #5a6268 !important;
        }
        .heatmap-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            padding: 15px;
            background: #fff3e0;
            border-radius: 8px;
            border: 1px solid #ffcc80;
        }
        .heatmap-control label {
            font-weight: bold;
            color: #e65100;
        }
        .heatmap-toggle {
            background: #ff9800 !important;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .heatmap-toggle:hover {
            background: #f57c00 !important;
        }
        .heatmap-toggle.active {
            background: #4caf50 !important;
        }
        .heatmap-slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        .heatmap-slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ff9800;
            cursor: pointer;
        }
        .heatmap-value {
            font-weight: bold;
            color: #ff9800;
            min-width: 40px;
            text-align: center;
        }
        .d3-full-graph {
            width: 100%;
            height: 800px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 20px 0;
            background: #f8f9fa;
        }
        .graph-stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #0596aa;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid;
        }
        .back-link {
            display: inline-block;
            background: #0596aa;
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            margin-top: 20px;
        }
        .back-link:hover {
            background: #047a8a;
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid #ffc107;
        }
        .tooltip .item-name {
            font-weight: bold;
            font-size: 14px;
            color: #ffc107;
            margin-bottom: 6px;
        }
        .tooltip .item-price {
            color: #ffc107;
            font-weight: bold;
            margin-bottom: 6px;
        }
        .tooltip .item-description {
            margin-bottom: 8px;
            line-height: 1.4;
            color: #ccc;
        }
        .tooltip .item-stats {
            margin-top: 8px;
        }
        .tooltip .stat-line {
            margin: 2px 0;
            color: #88ff88;
        }
        .filter-controls {
            margin: 15px 0;
            text-align: center;
        }
        .filter-controls label {
            margin: 0 10px;
            font-weight: bold;
        }
        .filter-controls input[type="range"] {
            width: 200px;
            margin: 0 10px;
        }
        .filter-controls select {
            margin: 0 10px;
            padding: 4px 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            min-height: 200px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #0596aa;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none;
        }
        .info-panel h3 {
            margin: 0 0 10px 0;
            color: #0596aa;
            font-size: 18px;
            font-weight: bold;
        }
        .info-panel .item-price {
            color: #ffc107;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
        }
        .info-panel .item-description {
            margin-bottom: 15px;
            line-height: 1.4;
            color: #555;
        }
        .info-panel .item-stats {
            margin-top: 10px;
        }
        .info-panel .stat-line {
            margin: 3px 0;
            color: #28a745;
            font-weight: bold;
        }
        .info-panel .connection-info {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        .info-panel .connection-info h4 {
            margin: 0 0 5px 0;
            color: #666;
            font-size: 14px;
        }
        .info-panel .depth-1 {
            color: #ff4444;
        }
        .info-panel .depth-2 {
            color: #ff8800;
        }
        
        /* 辺の長さ均等化のための視覚効果 */
        .uniform-edge-layout .node {
            opacity: 0.9;
        }
        
        .uniform-edge-layout .link {
            stroke-width: 2;
            opacity: 0.8;
        }
        
        .uniform-edge-layout .overlapping-nodes {
            stroke-width: 3;
            stroke-dasharray: 5,5;
        }
    </style>
</head>
<body>
    <div class="full-graph-container">
        <h1>出題範囲全アイテム関係性グラフ</h1>
        
        <div class="graph-stats">
            <div class="stat-item">
                <div class="stat-number" id="total-items">167</div>
                <div class="stat-label">総アイテム数</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="total-edges">332</div>
                <div class="stat-label">関係性数</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="basic-items">17</div>
                <div class="stat-label">素材アイテム</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="intermediate-items">43</div>
                <div class="stat-label">中間アイテム</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="legendary-items">103</div>
                <div class="stat-label">レジェンダリー</div>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #d4edda; border-color: #28a745;"></div>
                <span>素材アイテム（子がいない）</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #cce7ff; border-color: #007bff;"></div>
                <span>中間アイテム（親も子もいる）</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #fff3cd; border-color: #ffc107;"></div>
                <span>レジェンダリーアイテム（親がいない）</span>
            </div>
        </div>
        
        <div class="graph-controls">
            <button onclick="resetLayout()">レイアウト リセット</button>
            <button onclick="zoomToFit()">全体表示</button>
            <button onclick="pauseSimulation()">アニメーション 停止/再開</button>
        </div>
        
        <div class="edge-length-control">
            <label for="edge-length-slider">辺の長さ:</label>
            <input type="range" 
                   id="edge-length-slider" 
                   class="edge-length-slider"
                   min="100" 
                   max="500" 
                   value="120" 
                   step="10">
            <span id="edge-length-value" class="edge-length-value">120px</span>
            <button class="reset-button" onclick="resetEdgeLength()">リセット</button>
        </div>
        
        <div class="heatmap-control">
            <button id="heatmap-toggle" class="heatmap-toggle active" onclick="toggleHeatmap()">ヒートマップ ON</button>
            <span style="color: #e65100; font-weight: bold;">※ノード・ヒートマップ半径は価格準拠</span>
            <label for="heatmap-opacity-slider">透明度:</label>
            <input type="range" 
                   id="heatmap-opacity-slider" 
                   class="heatmap-slider"
                   min="10" 
                   max="60" 
                   value="40" 
                   step="5">
            <span id="heatmap-opacity-value" class="heatmap-value">40%</span>
        </div>
        
        <div class="filter-controls">
            <label for="radius-function">半径関数:</label>
            <select id="radius-function" onchange="updateRadiusFunction()">
                <option value="logarithmic">対数関数</option>
                <option value="exponential">指数関数</option>
                <option value="linear">線形関数</option>
                <option value="sqrt">ルート関数</option>
            </select>
            
            <label for="min-price">最低価格:</label>
            <input type="range" id="min-price" min="0" max="5000" value="0" step="100">
            <span id="min-price-value">0G</span>
            
            <label for="max-price">最高価格:</label>
            <input type="range" id="max-price" min="0" max="5000" value="5000" step="100">
            <span id="max-price-value">5000G</span>
            
            <button onclick="applyPriceFilter()">フィルター適用</button>
            <button onclick="clearFilter()">フィルター解除</button>
        </div>
        
        <div class="loading" id="loading">グラフデータを読み込み中...</div>
        
        <div id="d3-full-graph" class="d3-full-graph uniform-edge-layout" style="display: none; position: relative;">
            <div id="info-panel" class="info-panel">
                <h3 id="panel-title">アイテムを選択してください</h3>
                <div id="panel-content">
                    <p>アイテムにマウスを乗せると詳細情報が表示されます</p>
                    <p><strong>辺の長さ均等化モード</strong>: 全ての辺が同じ長さになるように配置されます</p>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 30px;">
            <h3>辺の長さ均等化モード</h3>
            <ul>
                <li><strong>均等な辺の長さ</strong>: 全ての辺が80pxの同じ長さになるように配置</li>
                <li><strong>幾何学的な美しさ</strong>: 規則正しいパターンで視覚的に美しいグラフ</li>
                <li><strong>重なり許容</strong>: ノードの重なりを許可し、構造を優先</li>
                <li><strong>自然な配置</strong>: 15秒間の物理シミュレーションで自然に収束</li>
            </ul>
            
            <h3>使い方</h3>
            <ul>
                <li><strong>レイアウト リセット</strong>: 新しいランダム配置で再計算</li>
                <li><strong>価格フィルター</strong>: 指定した価格帯のアイテムのみ表示</li>
                <li><strong>ズーム・パン</strong>: マウスホイールでズーム、ドラッグで移動</li>
                <li><strong>ノードドラッグ</strong>: ノードをドラッグして位置調整可能</li>
                <li><strong>深さ別ハイライト</strong>: ホバー時に関係性を色分け表示</li>
            </ul>
        </div>
        
        <a href="/" class="back-link">メインページに戻る</a>
        <a href="/quiz_a_algorithm" class="back-link">アルゴリズム解説に戻る</a>
    </div>

    <script>
        let fullGraphData = null;
        let simulation = null;
        let svg = null;
        let g = null;
        let nodes = null;
        let links = null;
        let filteredData = null;
        let isPaused = false;
        let heatmapGroup = null;
        let heatmapLayers = {};
        
        // ヒートマップ設定をグローバルに移動
        let heatmapEnabled = true;  // デフォルトでONに変更
        let heatmapOpacity = 0.4;   // より濃い透明度に変更
        // 注：heatmapRadiusは価格ベースになったため削除
        
        // アイテムタイプ別の色設定
        const heatmapColors = {
            ap: '#DA70D6',     // 明るい紫（orchid）
            ad: '#FF4500',     // 赤色（orangered）
            tank: '#32CD32',   // 明るい緑（limegreen）
            other: '#FFD700'   // その他は金色
        };
        
        // アイテムタイプ判定機能をグローバルに移動
        function getItemType(node) {
            const stats = node.stats || {};
            
            // APアイテム: FlatMagicDamageMod があるもの
            if (stats.FlatMagicDamageMod) {
                return 'ap';
            }
            // ADアイテム: FlatPhysicalDamageMod があるもの
            else if (stats.FlatPhysicalDamageMod) {
                return 'ad';
            }
            // タンクアイテム: FlatArmorMod または FlatSpellBlockMod があるもの
            else if (stats.FlatArmorMod || stats.FlatSpellBlockMod) {
                return 'tank';
            }
            // その他
            else {
                return 'other';
            }
        }
        
        // Kamada-Kawaiアルゴリズムの実装
        function calculateKamadaKawaiLayout(nodes, edges, width, height) {
            const n = nodes.length;
            if (n === 0) return;
            
            // Floyd-Warshallで全ノード間の最短経路を計算
            const dist = Array(n).fill(null).map(() => Array(n).fill(Infinity));
            const nodeIndex = {};
            
            // ノードのインデックスマッピング
            nodes.forEach((node, i) => {
                nodeIndex[node.id] = i;
                dist[i][i] = 0;
            });
            
            // エッジの距離を設定
            edges.forEach(edge => {
                const i = nodeIndex[edge.source.id || edge.source];
                const j = nodeIndex[edge.target.id || edge.target];
                if (i !== undefined && j !== undefined) {
                    dist[i][j] = 1;
                    dist[j][i] = 1;  // 無向グラフとして扱う
                }
            });
            
            // Floyd-Warshall
            for (let k = 0; k < n; k++) {
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (dist[i][k] + dist[k][j] < dist[i][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j];
                        }
                    }
                }
            }
            
            // 理想的な距離の計算（グラフ理論的距離に基づく）
            const L = Math.min(width, height) * 0.3;
            const idealDist = Array(n).fill(null).map(() => Array(n).fill(0));
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (dist[i][j] !== Infinity) {
                        idealDist[i][j] = L * dist[i][j] / Math.max(...dist.flat().filter(d => d !== Infinity));
                    }
                }
            }
            
            // 初期配置（円形）
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.4;
            
            nodes.forEach((node, i) => {
                const angle = (i / n) * 2 * Math.PI;
                node.x = centerX + radius * Math.cos(angle);
                node.y = centerY + radius * Math.sin(angle);
            });
            
            // Kamada-Kawai最適化（簡易版）- パフォーマンス改善
            const maxIterations = 20;  // 50から20に削減
            const threshold = 0.05;  // 0.01から0.05に緩和
            
            for (let iter = 0; iter < maxIterations; iter++) {
                let maxDelta = 0;
                
                // 各ノードについて最適な位置を計算
                for (let i = 0; i < n; i++) {
                    let fx = 0, fy = 0;
                    
                    for (let j = 0; j < n; j++) {
                        if (i !== j && idealDist[i][j] > 0) {
                            const dx = nodes[j].x - nodes[i].x;
                            const dy = nodes[j].y - nodes[i].y;
                            const currentDist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (currentDist > 0) {
                                const force = (idealDist[i][j] - currentDist) / currentDist;
                                fx += force * dx;
                                fy += force * dy;
                            }
                        }
                    }
                    
                    // 位置を更新
                    const stepSize = 0.1;
                    const deltaX = fx * stepSize;
                    const deltaY = fy * stepSize;
                    
                    nodes[i].x += deltaX;
                    nodes[i].y += deltaY;
                    
                    maxDelta = Math.max(maxDelta, Math.abs(deltaX) + Math.abs(deltaY));
                }
                
                // 収束判定
                if (maxDelta < threshold) break;
            }
            
            return nodes;
        }
        
        // 価格フィルターの値更新
        document.getElementById('min-price').addEventListener('input', function() {
            document.getElementById('min-price-value').textContent = this.value + 'G';
        });
        
        document.getElementById('max-price').addEventListener('input', function() {
            document.getElementById('max-price-value').textContent = this.value + 'G';
        });
        
        // グラフデータを読み込み
        async function loadGraphData() {
            try {
                const response = await fetch('/static/full_graph_data.json');
                fullGraphData = await response.json();
                
                // 統計情報を更新
                document.getElementById('total-items').textContent = fullGraphData.stats.total_items;
                document.getElementById('total-edges').textContent = fullGraphData.stats.edges;
                document.getElementById('basic-items').textContent = fullGraphData.stats.basic_items;
                document.getElementById('intermediate-items').textContent = fullGraphData.stats.intermediate_items;
                document.getElementById('legendary-items').textContent = fullGraphData.stats.legendary_items;
                
                document.getElementById('loading').style.display = 'none';
                initializeD3Graph();
                
            } catch (error) {
                console.error('グラフデータの読み込みに失敗:', error);
                document.getElementById('loading').textContent = 'データの読み込みに失敗しました。';
            }
        }
        
        function initializeD3Graph() {
            if (!fullGraphData) return;
            
            document.getElementById('d3-full-graph').style.display = 'block';
            
            // 既存のSVGを削除
            d3.select('#d3-full-graph').selectAll('*').remove();
            
            // コンテナのサイズを取得
            const container = document.getElementById('d3-full-graph');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // SVGを作成
            svg = d3.select('#d3-full-graph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // ズーム動作を追加
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // グラフコンテナ
            g = svg.append('g');
            
            // データをコピー（重複除去）
            const uniqueNodes = new Map();
            fullGraphData.nodes.forEach(node => {
                if (!uniqueNodes.has(node.id)) {
                    uniqueNodes.set(node.id, {...node});
                } else {
                    console.warn(`重複ノード検出: ${node.label} (ID: ${node.id})`);
                }
            });
            
            filteredData = {
                nodes: Array.from(uniqueNodes.values()),
                edges: fullGraphData.edges.map(d => ({...d}))
            };
            
            console.log(`ノード数（重複除去後）: ${filteredData.nodes.length}`);
            
            
            
            // 辺の長さ均等化システム
            let IDEAL_EDGE_LENGTH = 120;  // 理想的な辺の長さ（1.5倍）
            const centerX = width / 2;
            const centerY = height / 2;
            
            // 初期配置: 全ノードを中心付近にランダム配置
            filteredData.nodes.forEach(d => {
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * Math.min(width, height) * 0.3;
                d.x = centerX + r * Math.cos(angle);
                d.y = centerY + r * Math.sin(angle);
            });
            
            // 辺の長さ均等化とコリジョンのバランスを取ったシミュレーション
            simulation = d3.forceSimulation(filteredData.nodes)
                .force('link', d3.forceLink(filteredData.edges)
                    .id(d => d.id)
                    .distance(IDEAL_EDGE_LENGTH)  // 理想的な辺の長さ
                    .strength(0.8))  // 柔軟性を持たせて±10%程度の誤差を許容
                .force('charge', d3.forceManyBody()
                    .strength(-300)  // 適度な斥力
                    .distanceMax(IDEAL_EDGE_LENGTH * 2))  // 影響範囲を制限
                .force('center', d3.forceCenter(width / 2, height / 2).strength(0.1))
                .force('collision', d3.forceCollide()
                    .radius(d => getNodeRadius(d) * 1.05)  // 実際のサイズより少し大きめ
                    .strength(0.9)  // 強い衝突回避
                    .iterations(3))  // 精度向上のため反復回数増加
                .alphaDecay(0.005)  // ゆっくり収束で安定化
                .velocityDecay(0.2);  // 低い速度減衰で自然な動き
            
            // 15秒後に自動的にシミュレーションを停止
            setTimeout(() => {
                if (simulation) simulation.stop();
            }, 15000);
            
            // エッジを描画
            const linkGroup = g.append('g').attr('class', 'links');
            links = linkGroup.selectAll('line')
                .data(filteredData.edges)
                .join('line')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 1)
                .attr('marker-end', 'url(#arrowhead)');
            
            // 矢印マーカーとヒートマップグラデーションを定義
            const defs = svg.append('defs');
            
            // 矢印マーカー
            defs.append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#ccc');
            
            // ヒートマップ用radialGradientを作成
            function createHeatmapGradients() {
                Object.keys(heatmapColors).forEach(type => {
                    const gradient = defs.append('radialGradient')
                        .attr('id', `heatmap-gradient-${type}`)
                        .attr('cx', '50%')
                        .attr('cy', '50%')
                        .attr('r', '50%');
                    
                    // 中心は指定色、外側は透明
                    gradient.append('stop')
                        .attr('offset', '0%')
                        .attr('stop-color', heatmapColors[type])
                        .attr('stop-opacity', heatmapOpacity);
                    
                    gradient.append('stop')
                        .attr('offset', '100%')
                        .attr('stop-color', heatmapColors[type])
                        .attr('stop-opacity', 0);
                });
            }
            
            createHeatmapGradients();
            
            // ヒートマップレイヤーをアイテムタイプ別に作成（ノードより下に配置）
            heatmapGroup = g.append('g').attr('class', 'heatmap-layer');
            
            // アイテムタイプ別のサブグループを作成
            heatmapLayers = {};
            Object.keys(heatmapColors).forEach(type => {
                heatmapLayers[type] = heatmapGroup.append('g')
                    .attr('class', `heatmap-${type}`)
                    .style('mix-blend-mode', 'multiply'); // 同じ色同士は濃くなる
            });
            
            // 全体のヒートマップグループに異なる色同士の効果を適用
            heatmapGroup.style('mix-blend-mode', 'screen'); // 異なる色同士は白っぽくなる
            
            // ヒートマップ円を作成・更新する関数
            function updateHeatmap() {
                if (!heatmapEnabled) {
                    Object.values(heatmapLayers).forEach(layer => {
                        layer.selectAll('.heatmap-circle').remove();
                    });
                    return;
                }
                
                // アイテムタイプ別にデータを分ける
                const nodesByType = {};
                Object.keys(heatmapColors).forEach(type => {
                    nodesByType[type] = filteredData.nodes.filter(d => getItemType(d) === type);
                });
                
                // 各タイプ別にヒートマップ円を描画
                Object.keys(nodesByType).forEach(type => {
                    const layer = heatmapLayers[type];
                    const heatmapCircles = layer.selectAll('.heatmap-circle')
                        .data(nodesByType[type], d => d.id);
                    
                    heatmapCircles.exit().remove();
                    
                    const heatmapEnter = heatmapCircles.enter()
                        .append('circle')
                        .attr('class', 'heatmap-circle');
                    
                    heatmapCircles.merge(heatmapEnter)
                        .attr('r', d => getHeatmapRadius(d.price))  // 価格ベースの半径
                        .attr('fill', `url(#heatmap-gradient-${type})`)
                        .attr('cx', d => d.x || 0)
                        .attr('cy', d => d.y || 0);
                });
            }
            
            // ノードグループを作成
            const nodeGroup = g.append('g').attr('class', 'nodes');
            
            // ノードを描画
            nodes = nodeGroup.selectAll('.node')
                .data(filteredData.nodes)
                .join('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x},${d.y})`)  // 初期位置を設定
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // ホバー判定用の透明な大きな円（ノードサイズの1.5倍）
            nodes.append('circle')
                .attr('class', 'hover-area')
                .attr('r', d => getNodeRadius(d) * 1.5)
                .attr('fill', 'transparent')
                .attr('stroke', 'none')
                .style('cursor', 'pointer');
            
            // ノードのフレーム（円）
            nodes.append('circle')
                .attr('r', d => getNodeRadius(d))
                .attr('fill', 'none')
                .attr('stroke', d => getNodeColor(d).stroke)
                .attr('stroke-width', d => d.category === 'legendary' ? 4 : 3)
                .style('pointer-events', 'none');
            
            // アイテム画像
            nodes.append('image')
                .attr('href', d => `https://ddragon.leagueoflegends.com/cdn/{{ patch_version }}/img/item/${d.itemId}.png`)
                .attr('width', d => getNodeRadius(d) * 2)
                .attr('height', d => getNodeRadius(d) * 2)
                .attr('x', d => -getNodeRadius(d))
                .attr('y', d => -getNodeRadius(d))
                .style('clip-path', d => `circle(${getNodeRadius(d) - 2}px)`)
                .style('pointer-events', 'none');
            
            // テキストラベルを削除（画像のみで表示）
            
            // 固定情報パネルの実装
            const infoPanel = d3.select('#info-panel');
            const panelTitle = d3.select('#panel-title');
            const panelContent = d3.select('#panel-content');
            
            // 深さ別エッジハイライト機能
            function highlightConnectedEdges(hoveredNode) {
                // BFS で深さ1、2の接続を探索
                const depth1 = new Set();
                const depth2 = new Set();
                
                // 深さ1の接続を探索
                filteredData.edges.forEach(edge => {
                    if (edge.source.id === hoveredNode.id) {
                        depth1.add(edge.target.id);
                    } else if (edge.target.id === hoveredNode.id) {
                        depth1.add(edge.source.id);
                    }
                });
                
                // 深さ2の接続を探索
                depth1.forEach(nodeId => {
                    filteredData.edges.forEach(edge => {
                        if (edge.source.id === nodeId && edge.target.id !== hoveredNode.id && !depth1.has(edge.target.id)) {
                            depth2.add(edge.target.id);
                        } else if (edge.target.id === nodeId && edge.source.id !== hoveredNode.id && !depth1.has(edge.source.id)) {
                            depth2.add(edge.source.id);
                        }
                    });
                });
                
                // 関連ノードを収集（ホバー対象 + 深さ1 + 深さ2）
                const relatedNodes = new Set([hoveredNode.id, ...depth1, ...depth2]);
                
                // 関連ノードを最前面に移動
                nodes.each(function(d) {
                    if (relatedNodes.has(d.id)) {
                        d3.select(this).raise();
                    }
                });
                
                // ノードの見た目を更新（関連ノードは通常、その他は少し暗く）
                nodes.select('circle')
                    .attr('opacity', d => relatedNodes.has(d.id) ? 1.0 : 0.6);
                
                nodes.select('image')
                    .attr('opacity', d => relatedNodes.has(d.id) ? 1.0 : 0.5);
                
                // エッジの色とスタイルを更新
                links.attr('stroke', d => {
                    const sourceId = d.source.id;
                    const targetId = d.target.id;
                    
                    // 深さ1の接続
                    if ((sourceId === hoveredNode.id && depth1.has(targetId)) || 
                        (targetId === hoveredNode.id && depth1.has(sourceId))) {
                        return '#ff4444';  // 赤
                    }
                    // 深さ2の接続
                    else if ((depth1.has(sourceId) && depth2.has(targetId)) || 
                             (depth1.has(targetId) && depth2.has(sourceId))) {
                        return '#ff8800';  // オレンジ
                    }
                    // その他
                    else {
                        return '#ddd';  // 薄い灰色
                    }
                })
                .attr('stroke-width', d => {
                    const sourceId = d.source.id;
                    const targetId = d.target.id;
                    
                    // 深さ1の接続
                    if ((sourceId === hoveredNode.id && depth1.has(targetId)) || 
                        (targetId === hoveredNode.id && depth1.has(sourceId))) {
                        return 4;  // 太い
                    }
                    // 深さ2の接続
                    else if ((depth1.has(sourceId) && depth2.has(targetId)) || 
                             (depth1.has(targetId) && depth2.has(sourceId))) {
                        return 2;  // 中程度
                    }
                    // その他
                    else {
                        return 1;  // 細い
                    }
                })
                .attr('opacity', d => {
                    const sourceId = d.source.id;
                    const targetId = d.target.id;
                    
                    // 深さ1、2の接続
                    if ((sourceId === hoveredNode.id && depth1.has(targetId)) || 
                        (targetId === hoveredNode.id && depth1.has(sourceId)) ||
                        (depth1.has(sourceId) && depth2.has(targetId)) || 
                        (depth1.has(targetId) && depth2.has(sourceId))) {
                        return 1.0;  // 完全に表示
                    }
                    // その他
                    else {
                        return 0.3;  // 半透明
                    }
                });
                
                // ノードの強調
                nodes.select('circle').attr('stroke-width', d => {
                    if (d.id === hoveredNode.id) {
                        return 6;  // 選択されたノード
                    } else if (depth1.has(d.id)) {
                        return 4;  // 深さ1のノード
                    } else if (depth2.has(d.id)) {
                        return 3;  // 深さ2のノード
                    } else {
                        return d.category === 'legendary' ? 4 : 3;  // 通常
                    }
                })
                .attr('opacity', d => {
                    if (d.id === hoveredNode.id || depth1.has(d.id) || depth2.has(d.id)) {
                        return 1.0;  // 完全に表示
                    } else {
                        return 0.5;  // 半透明
                    }
                });
            }
            
            function resetHighlight() {
                // エッジを通常に戻す
                links.attr('stroke', '#ccc')
                     .attr('stroke-width', 1)
                     .attr('opacity', 1.0);
                
                // ノードを通常に戻す
                nodes.select('circle')
                     .attr('stroke-width', d => d.category === 'legendary' ? 4 : 3)
                     .attr('opacity', 1.0);
                
                nodes.select('image')
                     .attr('opacity', 1.0);
            }
            
            nodes.on('mouseover', function(event, d) {
                highlightConnectedEdges(d);
                showInfoPanel(d);
            })
            .on('mouseout', function(event, d) {
                resetHighlight();
                hideInfoPanel();
            });
            
            // シミュレーションの更新処理
            simulation.on('tick', () => {
                links
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                nodes
                    .attr('transform', d => `translate(${d.x},${d.y})`);
                
                // ヒートマップの位置も更新
                if (heatmapEnabled) {
                    Object.values(heatmapLayers).forEach(layer => {
                        layer.selectAll('.heatmap-circle')
                            .attr('cx', d => d.x)
                            .attr('cy', d => d.y);
                    });
                }
            });
            
            // ヒートマップの初期化（すべての要素が作成された後）
            updateHeatmap();
        }
        
        // 現在の半径関数タイプ
        let currentRadiusFunction = 'logarithmic';
        
        // 価格ベースの半径計算関数（関数タイプに応じて切り替え）
        function getPriceBasedRadius(price, minRadius = 8, maxRadius = 35) {
            const minPrice = 0;
            const maxPrice = 3500;
            
            // 価格が0の場合は最小半径
            if (price <= 0) return minRadius;
            
            const ratio = Math.min(price / maxPrice, 1);
            let scaledRatio;
            
            switch(currentRadiusFunction) {
                case 'logarithmic':
                    // 対数関数スケーリング
                    scaledRatio = Math.log(1 + ratio * 9) / Math.log(10);
                    break;
                case 'exponential':
                    // 指数関数スケーリング（x^2）
                    scaledRatio = Math.pow(ratio, 2);
                    break;
                case 'linear':
                    // 線形スケーリング
                    scaledRatio = ratio;
                    break;
                case 'sqrt':
                    // ルート関数スケーリング
                    scaledRatio = Math.sqrt(ratio);
                    break;
                default:
                    scaledRatio = ratio;
            }
            
            return minRadius + (maxRadius - minRadius) * scaledRatio;
        }
        
        // 半径関数変更時の処理
        function updateRadiusFunction() {
            currentRadiusFunction = document.getElementById('radius-function').value;
            
            // ノードの半径を更新
            if (typeof nodes !== 'undefined' && nodes) {
                svg.selectAll('.node circle')
                    .transition()
                    .duration(500)
                    .attr('r', d => getNodeRadius(d));
                    
                // ヒートマップも更新
                updateHeatmap();
            }
        }
        
        function getNodeRadius(d) {
            return getPriceBasedRadius(d.price || 0);
        }
        
        // ヒートマップ用の半径計算（ノード半径の4倍）
        function getHeatmapRadius(price) {
            const nodeRadius = getPriceBasedRadius(price || 0);
            return nodeRadius * 4.0; // ノード半径の4倍
        }
        
        function getNodeColor(d) {
            switch(d.category) {
                case 'basic': return { stroke: '#28a745' };
                case 'intermediate': return { stroke: '#007bff' };
                case 'legendary': return { stroke: '#ffc107' };
                default: return { stroke: '#6c757d' };
            }
        }
        
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            // 辺の長さ均等化では全ノードを自由に配置
            d.fx = null;
            d.fy = null;
        }
        
        
        function applyPriceFilter() {
            const minPrice = parseInt(document.getElementById('min-price').value);
            const maxPrice = parseInt(document.getElementById('max-price').value);
            
            if (!fullGraphData || !nodes) return;
            
            // フィルターされたデータを作成
            const filteredNodes = fullGraphData.nodes.filter(d => d.price >= minPrice && d.price <= maxPrice);
            const filteredNodeIds = new Set(filteredNodes.map(d => d.id));
            const filteredEdges = fullGraphData.edges.filter(d => 
                filteredNodeIds.has(d.source) && filteredNodeIds.has(d.target)
            );
            
            // optimalBasicOrderを関数内で定義（グループベース総当たり最適化）
            const optimalBasicOrder = [
                "1052", "1027", "1004", "1026", "1058", "3070", "1042",
                "1018", "1038", "1036", "1037", "1006", "1028", "1033",
                "1029", "2022"
            ];
            
            // データを更新（重複除去）
            const uniqueFilteredNodes = new Map();
            filteredNodes.forEach(node => {
                if (!uniqueFilteredNodes.has(node.id)) {
                    uniqueFilteredNodes.set(node.id, {...node});
                } else {
                    console.warn(`フィルタ後重複ノード検出: ${node.label} (ID: ${node.id})`);
                }
            });
            
            filteredData.nodes = Array.from(uniqueFilteredNodes.values());
            filteredData.edges = filteredEdges.map(d => ({...d}));
            
            console.log(`フィルタ後ノード数（重複除去後）: ${filteredData.nodes.length}`);
            
            // 辺の長さ均等化のため、フィルタ後も初期配置を再実行
            const container = document.getElementById('d3-full-graph');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            const IDEAL_EDGE_LENGTH = 120;
            
            // 全ノードを中心付近にランダム配置
            filteredData.nodes.forEach(d => {
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * Math.min(width, height) * 0.3;
                d.x = centerX + r * Math.cos(angle);
                d.y = centerY + r * Math.sin(angle);
            });
            
            // シミュレーションを再初期化
            simulation.nodes(filteredData.nodes);
            simulation.force('link').links(filteredData.edges);
            
            // DOMを更新
            links = links.data(filteredData.edges, d => d.source.id + '-' + d.target.id);
            links.exit().remove();
            links = links.enter().append('line')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 1)
                .attr('marker-end', 'url(#arrowhead)')
                .merge(links);
            
            nodes = nodes.data(filteredData.nodes, d => d.id);
            nodes.exit().remove();
            const nodeEnter = nodes.enter().append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // ホバー判定用の透明な大きな円
            nodeEnter.append('circle')
                .attr('class', 'hover-area')
                .attr('r', d => getNodeRadius(d) * 1.5)
                .attr('fill', 'transparent')
                .attr('stroke', 'none')
                .style('cursor', 'pointer');
            
            nodeEnter.append('circle')
                .attr('r', d => getNodeRadius(d))
                .attr('fill', 'none')
                .attr('stroke', d => getNodeColor(d).stroke)
                .attr('stroke-width', d => d.category === 'legendary' ? 4 : 3)
                .style('pointer-events', 'none');
            
            nodeEnter.append('image')
                .attr('href', d => `https://ddragon.leagueoflegends.com/cdn/{{ patch_version }}/img/item/${d.itemId}.png`)
                .attr('width', d => getNodeRadius(d) * 2)
                .attr('height', d => getNodeRadius(d) * 2)
                .attr('x', d => -getNodeRadius(d))
                .attr('y', d => -getNodeRadius(d))
                .style('clip-path', d => `circle(${getNodeRadius(d) - 2}px)`)
                .style('pointer-events', 'none');
            
            // テキストラベルを削除（画像のみで表示）
            
            nodes = nodeEnter.merge(nodes);
            
            // ホバーイベントを再設定
            nodes.on('mouseover', function(event, d) {
                highlightConnectedEdges(d);
                showInfoPanel(d);
            })
            .on('mouseout', function(event, d) {
                resetHighlight();
                hideInfoPanel();
            });
            
            // ヒートマップを更新
            if (typeof updateHeatmap === 'function') {
                updateHeatmap();
            }
            
            // シミュレーションを再開
            simulation.alpha(1).restart();
        }
        
        function clearFilter() {
            document.getElementById('min-price').value = 0;
            document.getElementById('max-price').value = 5000;
            document.getElementById('min-price-value').textContent = '0G';
            document.getElementById('max-price-value').textContent = '5000G';
            
            applyPriceFilter();
        }
        
        function resetLayout() {
            if (!simulation) return;
            
            const container = document.getElementById('d3-full-graph');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // 全ノードの固定を解除
            filteredData.nodes.forEach(d => {
                d.fx = null;
                d.fy = null;
                
                // 新しいランダム配置
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * Math.min(width, height) * 0.3;
                d.x = centerX + r * Math.cos(angle);
                d.y = centerY + r * Math.sin(angle);
            });
            
            // ヒートマップを更新
            if (typeof updateHeatmap === 'function') {
                updateHeatmap();
            }
            
            // シミュレーションを再開
            simulation.alpha(1).restart();
            
            // 15秒後に自動停止
            setTimeout(() => {
                if (simulation) simulation.stop();
            }, 15000);
        }
        
        function zoomToFit() {
            if (!svg || !g) return;
            
            const bounds = g.node().getBBox();
            const parent = svg.node().parentElement;
            const fullWidth = parent.clientWidth;
            const fullHeight = parent.clientHeight;
            
            const width = bounds.width;
            const height = bounds.height;
            
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;
            
            if (width == 0 || height == 0) return;
            
            const scale = 0.8 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
            
            svg.transition()
                .duration(750)
                .call(d3.zoom().transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
        }
        
        // 辺の長さスライダーのイベントリスナー
        const edgeLengthSlider = document.getElementById('edge-length-slider');
        const edgeLengthValue = document.getElementById('edge-length-value');
        
        edgeLengthSlider.addEventListener('input', function(e) {
            IDEAL_EDGE_LENGTH = parseInt(e.target.value);
            edgeLengthValue.textContent = IDEAL_EDGE_LENGTH + 'px';
            
            // シミュレーションを更新
            if (simulation) {
                simulation.force('link')
                    .distance(IDEAL_EDGE_LENGTH)
                    .strength(0.8);  // 柔軟性を保持
                
                simulation.force('charge')
                    .strength(-300)
                    .distanceMax(IDEAL_EDGE_LENGTH * 2);
                
                simulation.force('collision')
                    .radius(d => getNodeRadius(d) * 1.05)
                    .strength(0.9);
                
                simulation.alpha(0.5).restart();
            }
        });
        
        function resetEdgeLength() {
            edgeLengthSlider.value = 120;
            edgeLengthValue.textContent = '120px';
            IDEAL_EDGE_LENGTH = 120;
            
            if (simulation) {
                simulation.force('link')
                    .distance(IDEAL_EDGE_LENGTH)
                    .strength(0.8);  // 柔軟性を保持
                
                simulation.force('charge')
                    .strength(-300)
                    .distanceMax(IDEAL_EDGE_LENGTH * 2);
                
                simulation.force('collision')
                    .radius(d => getNodeRadius(d) * 1.05)
                    .strength(0.9);
                
                simulation.alpha(0.5).restart();
            }
        }
        
        // ヒートマップコントロール機能
        const heatmapToggle = document.getElementById('heatmap-toggle');
        const heatmapOpacitySlider = document.getElementById('heatmap-opacity-slider');
        const heatmapOpacityValue = document.getElementById('heatmap-opacity-value');
        
        // ヒートマップトグル機能
        function toggleHeatmap() {
            heatmapEnabled = !heatmapEnabled;
            heatmapToggle.classList.toggle('active', heatmapEnabled);
            heatmapToggle.textContent = heatmapEnabled ? 'ヒートマップ ON' : 'ヒートマップ OFF';
            
            if (typeof updateHeatmap === 'function') {
                updateHeatmap();
            }
        }
        
        
        // 透明度スライダーのイベントリスナー
        heatmapOpacitySlider.addEventListener('input', function(e) {
            heatmapOpacity = parseInt(e.target.value) / 100; // パーセントを小数に変換
            heatmapOpacityValue.textContent = e.target.value + '%';
            
            // グラデーションを再作成
            if (typeof createHeatmapGradients === 'function') {
                // 既存のグラデーションを削除
                svg.selectAll('radialGradient[id^="heatmap-gradient-"]').remove();
                createHeatmapGradients();
                
                if (heatmapEnabled && typeof updateHeatmap === 'function') {
                    updateHeatmap();
                }
            }
        });
        
        function pauseSimulation() {
            if (!simulation) return;
            
            if (isPaused) {
                simulation.restart();
                isPaused = false;
            } else {
                simulation.stop();
                isPaused = true;
            }
        }
        
        function showInfoPanel(d) {
            // BFS で深さ1、2の接続を探索（接続情報用）
            const depth1 = new Set();
            const depth2 = new Set();
            
            // 深さ1の接続を探索
            filteredData.edges.forEach(edge => {
                if (edge.source.id === d.id) {
                    depth1.add(edge.target.id);
                } else if (edge.target.id === d.id) {
                    depth1.add(edge.source.id);
                }
            });
            
            // 深さ2の接続を探索
            depth1.forEach(nodeId => {
                filteredData.edges.forEach(edge => {
                    if (edge.source.id === nodeId && edge.target.id !== d.id && !depth1.has(edge.target.id)) {
                        depth2.add(edge.target.id);
                    } else if (edge.target.id === nodeId && edge.source.id !== d.id && !depth1.has(edge.source.id)) {
                        depth2.add(edge.source.id);
                    }
                });
            });
            
            // ステータス情報を整形
            let statsHtml = '';
            if (d.stats && Object.keys(d.stats).length > 0) {
                statsHtml = '<div class="item-stats">';
                for (const [stat, value] of Object.entries(d.stats)) {
                    const statName = getStatName(stat);
                    if (statName && value !== 0) {
                        const displayValue = value > 0 ? `+${value}` : `${value}`;
                        statsHtml += `<div class="stat-line">${displayValue} ${statName}</div>`;
                    }
                }
                statsHtml += '</div>';
            }
            
            // 接続情報を整形
            let connectionHtml = '';
            if (depth1.size > 0 || depth2.size > 0) {
                connectionHtml = '<div class="connection-info">';
                if (depth1.size > 0) {
                    connectionHtml += `<h4>直接接続 <span class="depth-1">(${depth1.size}個)</span></h4>`;
                }
                if (depth2.size > 0) {
                    connectionHtml += `<h4>2段階接続 <span class="depth-2">(${depth2.size}個)</span></h4>`;
                }
                connectionHtml += '</div>';
            }
            
            // パネルの内容を更新
            panelTitle.text(d.label);
            panelContent.html(`
                <div class="item-price">${d.price}G</div>
                ${d.description ? `<div class="item-description">${d.description}</div>` : ''}
                ${statsHtml}
                ${connectionHtml}
            `);
            
            // パネルを表示
            infoPanel.style('display', 'block');
        }
        
        function hideInfoPanel() {
            infoPanel.style('display', 'none');
        }
        
        function getStatName(stat) {
            const statNames = {
                'FlatHPPoolMod': 'ヘルス',
                'FlatMPPoolMod': 'マナ', 
                'FlatArmorMod': '物理防御',
                'FlatSpellBlockMod': '魔法防御',
                'FlatPhysicalDamageMod': '攻撃力',
                'FlatMagicDamageMod': 'AP',
                'PercentAttackSpeedMod': '攻撃速度',
                'PercentMovementSpeedMod': '移動速度',
                'FlatCritChanceMod': 'クリティカル率',
                'FlatCritDamageMod': 'クリティカルダメージ',
                'PercentLifeStealMod': 'ライフスティール',
                'PercentSpellVampMod': 'スペルヴァンプ',
                'FlatHPRegenMod': 'ヘルス回復',
                'FlatMPRegenMod': 'マナ回復',
                'PercentHPRegenMod': 'ヘルス回復%',
                'PercentMPRegenMod': 'マナ回復%'
            };
            return statNames[stat] || stat;
        }
        
        // ページ読み込み時にデータを読み込み
        document.addEventListener('DOMContentLoaded', loadGraphData);
    </script>
</body>
</html>
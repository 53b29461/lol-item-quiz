<!DOCTYPE html>
<html>
<head>
    <title>å‡ºé¡Œç¯„å›²å…¨ã‚¢ã‚¤ãƒ†ãƒ é–¢ä¿‚æ€§ã‚°ãƒ©ãƒ• - League of Legends Item Quiz</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
    <script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .full-graph-container {
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .graph-controls {
            margin-bottom: 20px;
            text-align: center;
        }
        .graph-controls button {
            background: #0596aa;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 0 5px;
            border-radius: 5px;
            cursor: pointer;
        }
        .graph-controls button:hover {
            background: #047a8a;
        }
        .edge-length-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            padding: 15px;
            background: #f0f8ff;
            border-radius: 8px;
            border: 1px solid #b0d4f1;
        }
        .edge-length-control label {
            font-weight: bold;
            color: #2c3e50;
        }
        .edge-length-slider {
            width: 200px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        .edge-length-slider::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #0596aa;
            cursor: pointer;
        }
        .edge-length-value {
            font-weight: bold;
            color: #0596aa;
            min-width: 50px;
            text-align: center;
        }
        .reset-button {
            background: #6c757d !important;
            padding: 8px 16px !important;
            font-size: 12px !important;
        }
        .reset-button:hover {
            background: #5a6268 !important;
        }
        .heatmap-control {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin: 15px 0;
            padding: 15px;
            background: #fff3e0;
            border-radius: 8px;
            border: 1px solid #ffcc80;
        }
        .heatmap-control label {
            font-weight: bold;
            color: #e65100;
        }
        .heatmap-toggle {
            background: #ff9800 !important;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .heatmap-toggle:hover {
            background: #f57c00 !important;
        }
        .heatmap-toggle.active {
            background: #4caf50 !important;
        }
        .heatmap-slider {
            width: 120px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
        }
        .heatmap-slider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #ff9800;
            cursor: pointer;
        }
        .heatmap-value {
            font-weight: bold;
            color: #ff9800;
            min-width: 40px;
            text-align: center;
        }
        .d3-full-graph {
            width: 100%;
            height: 800px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 20px 0;
            background: #f8f9fa;
        }
        .graph-stats {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .stat-item {
            text-align: center;
        }
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #0596aa;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .legend {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 15px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 3px;
            border: 2px solid;
        }
        .back-link {
            display: inline-block;
            background: #0596aa;
            color: white;
            padding: 10px 20px;
            text-decoration: none;
            border-radius: 5px;
            margin-top: 20px;
        }
        .back-link:hover {
            background: #047a8a;
        }
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
            color: #666;
        }
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            border: 1px solid #ffc107;
        }
        .tooltip .item-name {
            font-weight: bold;
            font-size: 14px;
            color: #ffc107;
            margin-bottom: 6px;
        }
        .tooltip .item-price {
            color: #ffc107;
            font-weight: bold;
            margin-bottom: 6px;
        }
        .tooltip .item-description {
            margin-bottom: 8px;
            line-height: 1.4;
            color: #ccc;
        }
        .tooltip .item-stats {
            margin-top: 8px;
        }
        .tooltip .stat-line {
            margin: 2px 0;
            color: #88ff88;
        }
        .filter-controls {
            margin: 15px 0;
            text-align: center;
        }
        .filter-controls label {
            margin: 0 10px;
            font-weight: bold;
        }
        .filter-controls input[type="range"] {
            width: 200px;
            margin: 0 10px;
        }
        .filter-controls select {
            margin: 0 10px;
            padding: 4px 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .radius-controls {
            margin: 15px 0;
            padding: 15px;
            background: #f0f8ff;
            border-radius: 8px;
            border: 1px solid #87ceeb;
            text-align: center;
        }
        .radius-controls label {
            margin: 0 10px;
            font-weight: bold;
            color: #1e90ff;
        }
        .radius-controls input[type="range"] {
            width: 150px;
            margin: 0 10px;
        }
        .radius-value {
            font-weight: bold;
            color: #1e90ff;
            min-width: 40px;
            text-align: center;
            margin-right: 20px;
        }
        .info-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 300px;
            min-height: 200px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #0596aa;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: none;
        }
        .info-panel h3 {
            margin: 0 0 10px 0;
            color: #0596aa;
            font-size: 18px;
            font-weight: bold;
        }
        .info-panel .item-price {
            color: #ffc107;
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 10px;
        }
        .info-panel .item-description {
            margin-bottom: 15px;
            line-height: 1.4;
            color: #555;
        }
        .info-panel .item-stats {
            margin-top: 10px;
        }
        .info-panel .stat-line {
            margin: 3px 0;
            color: #28a745;
            font-weight: bold;
        }
        .info-panel .connection-info {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px solid #ddd;
        }
        .info-panel .connection-info h4 {
            margin: 0 0 5px 0;
            color: #666;
            font-size: 14px;
        }
        .info-panel .depth-1 {
            color: #ff4444;
        }
        .info-panel .depth-2 {
            color: #ff8800;
        }
        
        /* è¾ºã®é•·ã•å‡ç­‰åŒ–ã®ãŸã‚ã®è¦–è¦šåŠ¹æœ */
        .uniform-edge-layout .node {
            opacity: 0.9;
        }
        
        .uniform-edge-layout .link {
            stroke: #2c3e50;
            stroke-width: 2.5;
            opacity: 0.9;
            filter: drop-shadow(0 0 2px rgba(255, 255, 255, 0.3));
        }
        
        .uniform-edge-layout .overlapping-nodes {
            stroke-width: 3;
            stroke-dasharray: 5,5;
        }
    </style>
</head>
<body>
    <div class="full-graph-container">
        <h1>å‡ºé¡Œç¯„å›²å…¨ã‚¢ã‚¤ãƒ†ãƒ é–¢ä¿‚æ€§ã‚°ãƒ©ãƒ•</h1>
        
        <div class="graph-stats">
            <div class="stat-item">
                <div class="stat-number" id="total-items">167</div>
                <div class="stat-label">ç·ã‚¢ã‚¤ãƒ†ãƒ æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="total-edges">332</div>
                <div class="stat-label">é–¢ä¿‚æ€§æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="basic-items">17</div>
                <div class="stat-label">ç´ æã‚¢ã‚¤ãƒ†ãƒ </div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="intermediate-items">43</div>
                <div class="stat-label">ä¸­é–“ã‚¢ã‚¤ãƒ†ãƒ </div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="legendary-items">103</div>
                <div class="stat-label">ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼</div>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #d4edda; border-color: #28a745;"></div>
                <span>ç´ æã‚¢ã‚¤ãƒ†ãƒ ï¼ˆå­ãŒã„ãªã„ï¼‰</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #cce7ff; border-color: #007bff;"></div>
                <span>ä¸­é–“ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆè¦ªã‚‚å­ã‚‚ã„ã‚‹ï¼‰</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #fff3cd; border-color: #ffc107;"></div>
                <span>ãƒ¬ã‚¸ã‚§ãƒ³ãƒ€ãƒªãƒ¼ã‚¢ã‚¤ãƒ†ãƒ ï¼ˆè¦ªãŒã„ãªã„ï¼‰</span>
            </div>
        </div>
        
        <div class="graph-controls">
            <button onclick="resetLayout()">ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ ãƒªã‚»ãƒƒãƒˆ</button>
            <button onclick="zoomToFit()">å…¨ä½“è¡¨ç¤º</button>
            <button onclick="pauseSimulation()">ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ åœæ­¢/å†é–‹</button>
        </div>
        
        <div class="edge-length-control">
            <label for="edge-length-slider">è¾ºã®é•·ã•:</label>
            <input type="range" 
                   id="edge-length-slider" 
                   class="edge-length-slider"
                   min="100" 
                   max="500" 
                   value="120" 
                   step="10">
            <span id="edge-length-value" class="edge-length-value">120px</span>
            <button class="reset-button" onclick="resetEdgeLength()">ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
        
        <div class="heatmap-control">
            <button id="heatmap-toggle" class="heatmap-toggle active" onclick="toggleHeatmap()">ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ— ON</button>
            <span style="color: #e65100; font-weight: bold;">â€»ãƒãƒ¼ãƒ‰ãƒ»ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—åŠå¾„ã¯ä¾¡æ ¼æº–æ‹ </span>
            <label for="heatmap-opacity-slider">é€æ˜åº¦:</label>
            <input type="range" 
                   id="heatmap-opacity-slider" 
                   class="heatmap-slider"
                   min="10" 
                   max="60" 
                   value="40" 
                   step="5">
            <span id="heatmap-opacity-value" class="heatmap-value">40%</span>
        </div>
        
        <div class="filter-controls">
            <label for="radius-function">åŠå¾„é–¢æ•°:</label>
            <select id="radius-function">
                <option value="logarithmic">å¯¾æ•°é–¢æ•°</option>
                <option value="exponential">æŒ‡æ•°é–¢æ•°</option>
                <option value="linear">ç·šå½¢é–¢æ•°</option>
                <option value="sqrt">ãƒ«ãƒ¼ãƒˆé–¢æ•°</option>
            </select>
            <button onclick="updateRadiusFunction()">ã‚°ãƒ©ãƒ•æ›´æ–°</button>
            
            <div class="radius-controls">
                <label for="node-radius-multiplier">ãƒãƒ¼ãƒ‰åŠå¾„:</label>
                <input type="range" id="node-radius-multiplier" min="0.5" max="3.0" value="1.0" step="0.1">
                <span id="node-radius-value" class="radius-value">1.0x</span>
                
                <label for="heatmap-radius-multiplier">ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—åŠå¾„:</label>
                <input type="range" id="heatmap-radius-multiplier" min="0.5" max="5.0" value="1.0" step="0.1">
                <span id="heatmap-radius-value" class="radius-value">1.0x</span>
                
                <button onclick="resetRadiusMultipliers()" class="reset-button">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™</button>
            </div>
            
            <label for="min-price">æœ€ä½ä¾¡æ ¼:</label>
            <input type="range" id="min-price" min="0" max="5000" value="0" step="100">
            <span id="min-price-value">0G</span>
            
            <label for="max-price">æœ€é«˜ä¾¡æ ¼:</label>
            <input type="range" id="max-price" min="0" max="5000" value="5000" step="100">
            <span id="max-price-value">5000G</span>
            
            <button onclick="applyPriceFilter()">ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨</button>
            <button onclick="clearFilter()">ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è§£é™¤</button>
        </div>
        
        <div class="loading" id="loading">ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</div>
        
        <div id="d3-full-graph" class="d3-full-graph uniform-edge-layout" style="display: none; position: relative;">
            <div id="info-panel" class="info-panel">
                <h3 id="panel-title">ã‚¢ã‚¤ãƒ†ãƒ ã‚’é¸æŠã—ã¦ãã ã•ã„</h3>
                <div id="panel-content">
                    <p>ã‚¢ã‚¤ãƒ†ãƒ ã«ãƒã‚¦ã‚¹ã‚’ä¹—ã›ã‚‹ã¨è©³ç´°æƒ…å ±ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</p>
                    <p><strong>è¾ºã®é•·ã•å‡ç­‰åŒ–ãƒ¢ãƒ¼ãƒ‰</strong>: å…¨ã¦ã®è¾ºãŒåŒã˜é•·ã•ã«ãªã‚‹ã‚ˆã†ã«é…ç½®ã•ã‚Œã¾ã™</p>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 30px;">
            <h3>ğŸ¨ ãƒãƒ¼ãƒ‰ã®è‰²åˆ†ã‘ã«ã¤ã„ã¦</h3>
            <ul>
                <li><strong>ADï¼ˆç‰©ç†æ”»æ’ƒï¼‰</strong>: èµ¤è‰²ç³» - æ”»æ’ƒåŠ›ï¼ˆADï¼‰ã‚’é‡è¦–ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ </li>
                <li><strong>APï¼ˆé­”æ³•æ”»æ’ƒï¼‰</strong>: é’è‰²ç³» - é­”æ³•æ”»æ’ƒåŠ›ï¼ˆAPï¼‰ã‚’é‡è¦–ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ </li>
                <li><strong>ãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰</strong>: ç´«è‰²ç³» - ADãƒ»APä¸¡æ–¹ã‚’æŒã¤ã‚¢ã‚¤ãƒ†ãƒ </li>
                <li><strong>ç‰©ç†é˜²å¾¡ã‚¿ãƒ³ã‚¯</strong>: é»„è‰²ç³» - ç‰©ç†é˜²å¾¡ï¼ˆã‚¢ãƒ¼ãƒãƒ¼ï¼‰ã‚’é‡è¦–ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ </li>
                <li><strong>é­”æ³•é˜²å¾¡ã‚¿ãƒ³ã‚¯</strong>: æ©™è‰²ç³» - é­”æ³•é˜²å¾¡ï¼ˆMRï¼‰ã‚’é‡è¦–ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ </li>
                <li><strong>ã‚µãƒãƒ¼ãƒˆ</strong>: æ°´è‰²ç³» - ãƒ©ã‚¤ãƒ•ã‚¹ãƒ†ã‚£ãƒ¼ãƒ«ã€ãƒãƒŠå›å¾©ã‚’é‡è¦–ã™ã‚‹ã‚¢ã‚¤ãƒ†ãƒ </li>
                <li><strong>ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£</strong>: ç·‘è‰²ç³» - ç§»å‹•é€Ÿåº¦ã‚„ãã®ä»–ã®ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£åŠ¹æœ</li>
            </ul>
            
            <h3>ğŸ“ ãƒãƒ¼ãƒ‰ã®å¤§ãã•ã«ã¤ã„ã¦</h3>
            <ul>
                <li><strong>åŸºæœ¬ãƒ«ãƒ¼ãƒ«</strong>: ã‚¢ã‚¤ãƒ†ãƒ ã®ä¾¡æ ¼ã«å¿œã˜ã¦å¤§ãã•ãŒæ±ºã¾ã‚Šã¾ã™</li>
                <li><strong>åŠå¾„é–¢æ•°</strong>: 4ã¤ã®é–¢æ•°ã‹ã‚‰é¸æŠå¯èƒ½ã§ã€ä¾¡æ ¼ã¨å¤§ãã•ã®é–¢ä¿‚ã‚’èª¿æ•´ã§ãã¾ã™</li>
                <ul>
                    <li><strong>å¯¾æ•°é–¢æ•°</strong>: é«˜ä¾¡æ ¼ã‚¢ã‚¤ãƒ†ãƒ åŒå£«ã®å·®ã‚’å°ã•ãï¼ˆæ¨å¥¨ï¼‰</li>
                    <li><strong>æŒ‡æ•°é–¢æ•°</strong>: é«˜ä¾¡æ ¼ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚ˆã‚Šå¼·èª¿</li>
                    <li><strong>ç·šå½¢é–¢æ•°</strong>: ä¾¡æ ¼ã«æ¯”ä¾‹ã—ã¦å¤§ãã•ãŒå¢—åŠ </li>
                    <li><strong>ãƒ«ãƒ¼ãƒˆé–¢æ•°</strong>: ä½ä¾¡æ ¼ã‚¢ã‚¤ãƒ†ãƒ ã®å·®ã‚’å¤§ãã</li>
                </ul>
                <li><strong>èª¿æ•´ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼</strong>: ãƒãƒ¼ãƒ‰åŠå¾„å€ç‡ï¼ˆ0.5xï½3.0xï¼‰ã§æ‰‹å‹•èª¿æ•´å¯èƒ½</li>
            </ul>
            
            <h3>ğŸ¯ ãƒãƒ¼ãƒ‰ã®å¤–æ è‰²ã«ã¤ã„ã¦</h3>
            <ul>
                <li><strong>èµ¤è‰²ï¼ˆæ¿ƒã„èµ¤ï¼‰</strong>: é¸æŠã•ã‚ŒãŸãƒãƒ¼ãƒ‰ - è©³ç´°æƒ…å ±ã‚’è¡¨ç¤ºä¸­</li>
                <li><strong>ã‚ªãƒ¬ãƒ³ã‚¸è‰²</strong>: ç›´æ¥é–¢é€£ãƒãƒ¼ãƒ‰ - é¸æŠãƒãƒ¼ãƒ‰ã‹ã‚‰1ã¤å…ˆã®ã‚¢ã‚¤ãƒ†ãƒ </li>
                <li><strong>é’è‰²</strong>: é–“æ¥é–¢é€£ãƒãƒ¼ãƒ‰ - é¸æŠãƒãƒ¼ãƒ‰ã‹ã‚‰2ã¤å…ˆã®ã‚¢ã‚¤ãƒ†ãƒ </li>
                <li><strong>é»’è‰²</strong>: é€šå¸¸çŠ¶æ…‹ - é¸æŠã•ã‚Œã¦ã„ãªã„ãƒãƒ¼ãƒ‰</li>
            </ul>
            
            <h3>ğŸŒˆ ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—æ©Ÿèƒ½</h3>
            <ul>
                <li><strong>é‡ãªã‚Šè¡¨ç¤º</strong>: å„ãƒãƒ¼ãƒ‰ã®å‘¨å›²ã«è‰²ä»˜ãã®å††ã‚’è¡¨ç¤º</li>
                <li><strong>é€æ˜åº¦èª¿æ•´</strong>: 10%ï½60%ã®ç¯„å›²ã§èª¿æ•´å¯èƒ½</li>
                <li><strong>åŠå¾„èª¿æ•´</strong>: ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—åŠå¾„å€ç‡ï¼ˆ0.5xï½5.0xï¼‰ã§èª¿æ•´å¯èƒ½</li>
                <li><strong>é‡ãªã‚ŠåŠ¹æœ</strong>: è¤‡æ•°ã®ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ãŒé‡ãªã‚‹ã¨è‰²ãŒæ··åˆã•ã‚Œã¾ã™</li>
                <li><strong>ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³</strong>: ä¸­å¿ƒã‹ã‚‰å¤–å´ã«å‘ã‹ã£ã¦é€æ˜åº¦ãŒå¤‰åŒ–</li>
            </ul>
            
            <h3>ğŸ–±ï¸ ãƒã‚¦ã‚¹æ“ä½œã«ã¤ã„ã¦</h3>
            <ul>
                <li><strong>ãƒãƒ¼ãƒ‰é¸æŠ</strong>: ã‚¢ã‚¤ãƒ†ãƒ ã«ãƒã‚¦ã‚¹ã‚’ä¹—ã›ã‚‹ã¨è©³ç´°æƒ…å ±ãŒè¡¨ç¤ºã•ã‚Œã¾ã™</li>
                <li><strong>é–¢ä¿‚æ€§è¡¨ç¤º</strong>: é¸æŠã—ãŸã‚¢ã‚¤ãƒ†ãƒ ã‹ã‚‰æ´¾ç”Ÿã™ã‚‹é–¢ä¿‚ã‚’è‰²åˆ†ã‘ã§è¡¨ç¤º</li>
                <li><strong>ãƒãƒ¼ãƒ‰ãƒ‰ãƒ©ãƒƒã‚°</strong>: ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦å¼•ã£å¼µã‚‹ã“ã¨ã§ä½ç½®ã‚’èª¿æ•´ã§ãã¾ã™</li>
                <li><strong>ã‚°ãƒ©ãƒ•å…¨ä½“ã®ç§»å‹•</strong>: ç©ºã„ã¦ã„ã‚‹å ´æ‰€ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦ã‚°ãƒ©ãƒ•å…¨ä½“ã‚’ç§»å‹•</li>
                <li><strong>æ‹¡å¤§ãƒ»ç¸®å°</strong>: ãƒã‚¦ã‚¹ãƒ›ã‚¤ãƒ¼ãƒ«ã§ã‚ºãƒ¼ãƒ ã‚¤ãƒ³ãƒ»ã‚ºãƒ¼ãƒ ã‚¢ã‚¦ãƒˆ</li>
            </ul>
            
            <h3>âš™ï¸ è¾ºã®é•·ã•å‡ç­‰åŒ–ãƒ¢ãƒ¼ãƒ‰</h3>
            <ul>
                <li><strong>å‡ç­‰ãªè¾ºã®é•·ã•</strong>: å…¨ã¦ã®è¾ºãŒåŒã˜é•·ã•ã«ãªã‚‹ã‚ˆã†ã«é…ç½®</li>
                <li><strong>å¹¾ä½•å­¦çš„ãªç¾ã—ã•</strong>: è¦å‰‡æ­£ã—ã„ãƒ‘ã‚¿ãƒ¼ãƒ³ã§è¦–è¦šçš„ã«ç¾ã—ã„ã‚°ãƒ©ãƒ•</li>
                <li><strong>é‡ãªã‚Šè¨±å®¹</strong>: ãƒãƒ¼ãƒ‰ã®é‡ãªã‚Šã‚’è¨±å¯ã—ã€æ§‹é€ ã‚’å„ªå…ˆ</li>
                <li><strong>è‡ªç„¶ãªé…ç½®</strong>: 15ç§’é–“ã®ç‰©ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã§è‡ªç„¶ã«åæŸ</li>
                <li><strong>ã‚¨ãƒƒã‚¸ã®è‰²</strong>: è¦–èªæ€§ã‚’é‡è¦–ã—ã€é»’è‰²ã§çµ±ä¸€ï¼ˆç™½ã„ãƒ‰ãƒ­ãƒƒãƒ—ã‚·ãƒ£ãƒ‰ã‚¦ä»˜ãï¼‰</li>
            </ul>
            
            <h3>ğŸ” é™¤å¤–ã•ã‚Œã¦ã„ã‚‹ã‚¢ã‚¤ãƒ†ãƒ ã«ã¤ã„ã¦</h3>
            <ul>
                <li><strong>é™¤å¤–ç†ç”±</strong>: å‡ºé¡Œç¯„å›²å¤–ã®ã‚¢ã‚¤ãƒ†ãƒ ã¯è¡¨ç¤ºã•ã‚Œã¾ã›ã‚“</li>
                <li><strong>é™¤å¤–ã•ã‚Œã‚‹ã‚¢ã‚¤ãƒ†ãƒ </strong>: 
                    <ul>
                        <li>ãƒ–ãƒ¼ãƒ„é¡ - ç§»å‹•é€Ÿåº¦ã‚¢ã‚¤ãƒ†ãƒ ã¯å‡ºé¡Œå¯¾è±¡å¤–</li>
                        <li>ãƒ¯ãƒ¼ãƒ‰ãƒ»ãƒˆãƒªãƒ³ã‚±ãƒƒãƒˆ - è¦–ç•Œç³»ã‚¢ã‚¤ãƒ†ãƒ ã¯å‡ºé¡Œå¯¾è±¡å¤–</li>
                        <li>ãƒãƒ¼ã‚·ãƒ§ãƒ³é¡ - æ¶ˆè²»ã‚¢ã‚¤ãƒ†ãƒ ã¯å‡ºé¡Œå¯¾è±¡å¤–</li>
                        <li>ç¥è©±ç´šã‚¢ã‚¤ãƒ†ãƒ  - ç¾åœ¨ã®ãƒ‘ãƒƒãƒã§ã¯å¯¾è±¡å¤–</li>
                        <li>ä¸€éƒ¨ã®ã‚µãƒãƒ¼ãƒˆã‚¢ã‚¤ãƒ†ãƒ  - å°‚ç”¨ã‚¢ã‚¤ãƒ†ãƒ ã¯å‡ºé¡Œå¯¾è±¡å¤–</li>
                    </ul>
                </li>
                <li><strong>å¯¾è±¡ã‚¢ã‚¤ãƒ†ãƒ </strong>: ä¸»è¦ãªè£…å‚™å“ï¼ˆæ­¦å™¨ã€é˜²å…·ã€ã‚¢ã‚¯ã‚»ã‚µãƒªãƒ¼ï¼‰ã®ã¿è¡¨ç¤º</li>
            </ul>
            
            <h3>ğŸ’¡ ä½¿ã„æ–¹ã®ã‚³ãƒ„</h3>
            <ul>
                <li><strong>ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ ãƒªã‚»ãƒƒãƒˆ</strong>: æ–°ã—ã„ãƒ©ãƒ³ãƒ€ãƒ é…ç½®ã§å†è¨ˆç®—</li>
                <li><strong>ä¾¡æ ¼ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼</strong>: æŒ‡å®šã—ãŸä¾¡æ ¼å¸¯ã®ã‚¢ã‚¤ãƒ†ãƒ ã®ã¿è¡¨ç¤º</li>
                <li><strong>åŠå¾„èª¿æ•´</strong>: è¦‹ã‚„ã™ã•ã«å¿œã˜ã¦ãƒãƒ¼ãƒ‰ãƒ»ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã®å¤§ãã•ã‚’èª¿æ•´</li>
                <li><strong>é€æ˜åº¦èª¿æ•´</strong>: ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã®é€æ˜åº¦ã‚’èª¿æ•´ã—ã¦èƒŒæ™¯ã®è¦‹ã‚„ã™ã•ã‚’èª¿æ•´</li>
                <li><strong>é–¢æ•°é¸æŠ</strong>: ã‚¢ã‚¤ãƒ†ãƒ ã®ä¾¡æ ¼å·®ã‚’å¼·èª¿ã—ãŸã„å ´åˆã¯æŒ‡æ•°é–¢æ•°ã‚’é¸æŠ</li>
            </ul>
        </div>
        
        <a href="/" class="back-link">ãƒ¡ã‚¤ãƒ³ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹</a>
        <a href="/quiz_a_algorithm" class="back-link">ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ è§£èª¬ã«æˆ»ã‚‹</a>
    </div>

    <script>
        let fullGraphData = null;
        let simulation = null;
        let svg = null;
        let g = null;
        let nodes = null;
        let links = null;
        let filteredData = null;
        let isPaused = false;
        let heatmapGroup = null;
        let heatmapLayers = {};
        let nodeRadiusMultiplier = 1.0;
        let heatmapRadiusMultiplier = 1.0;
        
        // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—è¨­å®šã‚’ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«ç§»å‹•
        let heatmapEnabled = true;  // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã§ONã«å¤‰æ›´
        let heatmapOpacity = 0.4;   // ã‚ˆã‚Šæ¿ƒã„é€æ˜åº¦ã«å¤‰æ›´
        // æ³¨ï¼šheatmapRadiusã¯ä¾¡æ ¼ãƒ™ãƒ¼ã‚¹ã«ãªã£ãŸãŸã‚å‰Šé™¤
        
        // ã‚¢ã‚¤ãƒ†ãƒ ã‚¿ã‚¤ãƒ—åˆ¥ã®è©³ç´°è‰²è¨­å®šï¼ˆ11åˆ†é¡ï¼‰
        const heatmapColors = {
            pureAP: '#8A2BE2',        // æ˜ã‚‹ã„ç´« - ç´”ç²‹AP
            apHybrid: '#6A5ACD',      // é’ç´« - APãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰
            pureAD: '#DC143C',        // èµ¤ - ç´”ç²‹AD
            adCrit: '#FF8C00',        // ã‚ªãƒ¬ãƒ³ã‚¸ - ADã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«
            adAS: '#FFD700',          // é»„ã‚ªãƒ¬ãƒ³ã‚¸ - ADæ”»æ’ƒé€Ÿåº¦
            tankHP: '#228B22',        // æ¿ƒã„ç·‘ - HPã‚¿ãƒ³ã‚¯
            tankArmor: '#8B4513',     // èŒ¶è‰² - ç‰©ç†é˜²å¾¡ã‚¿ãƒ³ã‚¯
            tankMR: '#20B2AA',        // é’ç·‘ - é­”æ³•é˜²å¾¡ã‚¿ãƒ³ã‚¯
            support: '#FF69B4',       // ãƒ”ãƒ³ã‚¯ - ã‚µãƒãƒ¼ãƒˆ
            utility: '#00CED1',       // æ°´è‰² - ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
            hybrid: '#DA70D6'         // ç´«ãƒ”ãƒ³ã‚¯ - è¤‡åˆã‚¢ã‚¤ãƒ†ãƒ 
        };
        
        // è¦–èªæ€§å‘ä¸Šã®ãŸã‚ã®è¾ºã®è‰²ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—è‰²ã®è£œè‰²ç³»ï¼‰
        const edgeColors = {
            'default': '#333333',        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼ˆæ¿ƒã„ã‚°ãƒ¬ãƒ¼ï¼‰
            'pureAP': '#FFD700',        // é‡‘è‰²ï¼ˆç´«ã®è£œè‰²ç³»ï¼‰
            'apHybrid': '#FF6347',      // ãƒˆãƒãƒˆè‰²ï¼ˆé’ç´«ã®è£œè‰²ç³»ï¼‰
            'pureAD': '#00CED1',        // æ°´è‰²ï¼ˆèµ¤ã®è£œè‰²ï¼‰
            'adCrit': '#4169E1',        // ãƒ­ã‚¤ãƒ¤ãƒ«ãƒ–ãƒ«ãƒ¼ï¼ˆã‚ªãƒ¬ãƒ³ã‚¸ã®è£œè‰²ï¼‰
            'adAS': '#8A2BE2',          // ç´«ï¼ˆé»„è‰²ã®è£œè‰²ï¼‰
            'tankHP': '#FF69B4',        // ãƒ”ãƒ³ã‚¯ï¼ˆç·‘ã®è£œè‰²ï¼‰
            'tankArmor': '#00FFFF',     // ã‚·ã‚¢ãƒ³ï¼ˆèŒ¶è‰²ã®è£œè‰²ï¼‰
            'tankMR': '#FF4500',        // ã‚ªãƒ¬ãƒ³ã‚¸ãƒ¬ãƒƒãƒ‰ï¼ˆé’ç·‘ã®è£œè‰²ï¼‰
            'support': '#32CD32',       // ç·‘ï¼ˆãƒ”ãƒ³ã‚¯ã®è£œè‰²ï¼‰
            'utility': '#FF8C00',       // ã‚ªãƒ¬ãƒ³ã‚¸ï¼ˆæ°´è‰²ã®è£œè‰²ï¼‰
            'hybrid': '#00FA9A'         // ç·‘ï¼ˆç´«ãƒ”ãƒ³ã‚¯ã®è£œè‰²ï¼‰
        };
        
        // ã‚¢ã‚¤ãƒ†ãƒ ã‚¿ã‚¤ãƒ—åˆ¤å®šæ©Ÿèƒ½ï¼ˆè©³ç´°11åˆ†é¡ï¼‰
        function getItemType(node) {
            const stats = node.stats || {};
            
            // å„çµ±è¨ˆã®æœ‰ç„¡ã‚’ç¢ºèª
            const hasAP = stats.FlatMagicDamageMod > 0;
            const hasAD = stats.FlatPhysicalDamageMod > 0;
            const hasCrit = stats.FlatCritChanceMod > 0;
            const hasAS = stats.PercentAttackSpeedMod > 0;
            const hasHP = stats.FlatHPPoolMod > 0;
            const hasArmor = stats.FlatArmorMod > 0;
            const hasMR = stats.FlatSpellBlockMod > 0;
            const hasMP = stats.FlatMPPoolMod > 0;
            const hasLS = stats.PercentLifeStealMod > 0;
            const hasMS = stats.FlatMovementSpeedMod > 0 || stats.PercentMovementSpeedMod > 0;
            
            // è¤‡æ•°ã‚«ãƒ†ã‚´ãƒªåˆ¤å®šã®ãŸã‚ã®ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼
            const attackCount = (hasAP ? 1 : 0) + (hasAD ? 1 : 0);
            const defenseCount = (hasHP ? 1 : 0) + (hasArmor ? 1 : 0) + (hasMR ? 1 : 0);
            const utilityCount = (hasMP ? 1 : 0) + (hasLS ? 1 : 0) + (hasMS ? 1 : 0);
            
            // è¤‡åˆã‚¢ã‚¤ãƒ†ãƒ åˆ¤å®šï¼ˆ3ã¤ä»¥ä¸Šã®ç•°ãªã‚‹ã‚«ãƒ†ã‚´ãƒªã‚’æŒã¤ï¼‰
            const totalCategories = (attackCount > 0 ? 1 : 0) + (defenseCount > 0 ? 1 : 0) + (utilityCount > 0 ? 1 : 0);
            if (totalCategories >= 3) {
                return 'hybrid';
            }
            
            // ç´”ç²‹AP (APã®ã¿ã€ã¾ãŸã¯AP + ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£)
            if (hasAP && !hasAD && !hasHP && !hasArmor && !hasMR) {
                return 'pureAP';
            }
            
            // APãƒã‚¤ãƒ–ãƒªãƒƒãƒ‰ (AP + é˜²å¾¡èƒ½åŠ›)
            if (hasAP && (hasHP || hasArmor || hasMR)) {
                return 'apHybrid';
            }
            
            // ADã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ« (AD + ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«)
            if (hasAD && hasCrit) {
                return 'adCrit';
            }
            
            // ADæ”»æ’ƒé€Ÿåº¦ (AD + æ”»æ’ƒé€Ÿåº¦)
            if (hasAD && hasAS) {
                return 'adAS';
            }
            
            // ç´”ç²‹AD (ADã®ã¿ã€ã¾ãŸã¯AD + ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£)
            if (hasAD && !hasCrit && !hasAS && !hasHP && !hasArmor && !hasMR) {
                return 'pureAD';
            }
            
            // HPã‚¿ãƒ³ã‚¯ (HPä¸»ä½“)
            if (hasHP && !hasAP && !hasAD) {
                return 'tankHP';
            }
            
            // ç‰©ç†é˜²å¾¡ã‚¿ãƒ³ã‚¯ (Armorä¸»ä½“)
            if (hasArmor && !hasAP && !hasAD && !hasMR) {
                return 'tankArmor';
            }
            
            // é­”æ³•é˜²å¾¡ã‚¿ãƒ³ã‚¯ (MRä¸»ä½“)
            if (hasMR && !hasAP && !hasAD && !hasArmor) {
                return 'tankMR';
            }
            
            // ã‚µãƒãƒ¼ãƒˆ (ãƒ©ã‚¤ãƒ•ã‚¹ãƒ†ã‚£ãƒ¼ãƒ«ä¸»ä½“)
            if (hasLS || (hasMP && !hasAP)) {
                return 'support';
            }
            
            // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ (ç§»å‹•é€Ÿåº¦ä¸»ä½“)
            if (hasMS && !hasAP && !hasAD) {
                return 'utility';
            }
            
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼šçµ±è¨ˆãŒãªã„å ´åˆã¯ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
            return 'utility';
        }
        
        // Kamada-Kawaiã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å®Ÿè£…
        function calculateKamadaKawaiLayout(nodes, edges, width, height) {
            const n = nodes.length;
            if (n === 0) return;
            
            // Floyd-Warshallã§å…¨ãƒãƒ¼ãƒ‰é–“ã®æœ€çŸ­çµŒè·¯ã‚’è¨ˆç®—
            const dist = Array(n).fill(null).map(() => Array(n).fill(Infinity));
            const nodeIndex = {};
            
            // ãƒãƒ¼ãƒ‰ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ”ãƒ³ã‚°
            nodes.forEach((node, i) => {
                nodeIndex[node.id] = i;
                dist[i][i] = 0;
            });
            
            // ã‚¨ãƒƒã‚¸ã®è·é›¢ã‚’è¨­å®š
            edges.forEach(edge => {
                const i = nodeIndex[edge.source.id || edge.source];
                const j = nodeIndex[edge.target.id || edge.target];
                if (i !== undefined && j !== undefined) {
                    dist[i][j] = 1;
                    dist[j][i] = 1;  // ç„¡å‘ã‚°ãƒ©ãƒ•ã¨ã—ã¦æ‰±ã†
                }
            });
            
            // Floyd-Warshall
            for (let k = 0; k < n; k++) {
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (dist[i][k] + dist[k][j] < dist[i][j]) {
                            dist[i][j] = dist[i][k] + dist[k][j];
                        }
                    }
                }
            }
            
            // ç†æƒ³çš„ãªè·é›¢ã®è¨ˆç®—ï¼ˆã‚°ãƒ©ãƒ•ç†è«–çš„è·é›¢ã«åŸºã¥ãï¼‰
            const L = Math.min(width, height) * 0.3;
            const idealDist = Array(n).fill(null).map(() => Array(n).fill(0));
            
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < n; j++) {
                    if (dist[i][j] !== Infinity) {
                        idealDist[i][j] = L * dist[i][j] / Math.max(...dist.flat().filter(d => d !== Infinity));
                    }
                }
            }
            
            // åˆæœŸé…ç½®ï¼ˆå††å½¢ï¼‰
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = Math.min(width, height) * 0.4;
            
            nodes.forEach((node, i) => {
                const angle = (i / n) * 2 * Math.PI;
                node.x = centerX + radius * Math.cos(angle);
                node.y = centerY + radius * Math.sin(angle);
            });
            
            // Kamada-Kawaiæœ€é©åŒ–ï¼ˆç°¡æ˜“ç‰ˆï¼‰- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ”¹å–„
            const maxIterations = 20;  // 50ã‹ã‚‰20ã«å‰Šæ¸›
            const threshold = 0.05;  // 0.01ã‹ã‚‰0.05ã«ç·©å’Œ
            
            for (let iter = 0; iter < maxIterations; iter++) {
                let maxDelta = 0;
                
                // å„ãƒãƒ¼ãƒ‰ã«ã¤ã„ã¦æœ€é©ãªä½ç½®ã‚’è¨ˆç®—
                for (let i = 0; i < n; i++) {
                    let fx = 0, fy = 0;
                    
                    for (let j = 0; j < n; j++) {
                        if (i !== j && idealDist[i][j] > 0) {
                            const dx = nodes[j].x - nodes[i].x;
                            const dy = nodes[j].y - nodes[i].y;
                            const currentDist = Math.sqrt(dx * dx + dy * dy);
                            
                            if (currentDist > 0) {
                                const force = (idealDist[i][j] - currentDist) / currentDist;
                                fx += force * dx;
                                fy += force * dy;
                            }
                        }
                    }
                    
                    // ä½ç½®ã‚’æ›´æ–°
                    const stepSize = 0.1;
                    const deltaX = fx * stepSize;
                    const deltaY = fy * stepSize;
                    
                    nodes[i].x += deltaX;
                    nodes[i].y += deltaY;
                    
                    maxDelta = Math.max(maxDelta, Math.abs(deltaX) + Math.abs(deltaY));
                }
                
                // åæŸåˆ¤å®š
                if (maxDelta < threshold) break;
            }
            
            return nodes;
        }
        
        // ä¾¡æ ¼ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã®å€¤æ›´æ–°
        document.getElementById('min-price').addEventListener('input', function() {
            document.getElementById('min-price-value').textContent = this.value + 'G';
        });
        
        document.getElementById('max-price').addEventListener('input', function() {
            document.getElementById('max-price-value').textContent = this.value + 'G';
        });
        
        // ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        async function loadGraphData() {
            try {
                const response = await fetch('/static/full_graph_data.json');
                fullGraphData = await response.json();
                
                // çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°
                document.getElementById('total-items').textContent = fullGraphData.stats.total_items;
                document.getElementById('total-edges').textContent = fullGraphData.stats.edges;
                document.getElementById('basic-items').textContent = fullGraphData.stats.basic_items;
                document.getElementById('intermediate-items').textContent = fullGraphData.stats.intermediate_items;
                document.getElementById('legendary-items').textContent = fullGraphData.stats.legendary_items;
                
                document.getElementById('loading').style.display = 'none';
                initializeD3Graph();
                
            } catch (error) {
                console.error('ã‚°ãƒ©ãƒ•ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—:', error);
                document.getElementById('loading').textContent = 'ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
            }
        }
        
        function initializeD3Graph() {
            if (!fullGraphData) return;
            
            document.getElementById('d3-full-graph').style.display = 'block';
            
            // æ—¢å­˜ã®SVGã‚’å‰Šé™¤
            d3.select('#d3-full-graph').selectAll('*').remove();
            
            // ã‚³ãƒ³ãƒ†ãƒŠã®ã‚µã‚¤ã‚ºã‚’å–å¾—
            const container = document.getElementById('d3-full-graph');
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // SVGã‚’ä½œæˆ
            svg = d3.select('#d3-full-graph')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // ã‚ºãƒ¼ãƒ å‹•ä½œã‚’è¿½åŠ 
            const zoom = d3.zoom()
                .scaleExtent([0.1, 4])
                .on('zoom', (event) => {
                    g.attr('transform', event.transform);
                });
            
            svg.call(zoom);
            
            // ã‚°ãƒ©ãƒ•ã‚³ãƒ³ãƒ†ãƒŠ
            g = svg.append('g');
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’ã‚³ãƒ”ãƒ¼ï¼ˆé‡è¤‡é™¤å»ï¼‰
            const uniqueNodes = new Map();
            fullGraphData.nodes.forEach(node => {
                if (!uniqueNodes.has(node.id)) {
                    uniqueNodes.set(node.id, {...node});
                } else {
                    console.warn(`é‡è¤‡ãƒãƒ¼ãƒ‰æ¤œå‡º: ${node.label} (ID: ${node.id})`);
                }
            });
            
            filteredData = {
                nodes: Array.from(uniqueNodes.values()),
                edges: fullGraphData.edges.map(d => ({...d}))
            };
            
            console.log(`ãƒãƒ¼ãƒ‰æ•°ï¼ˆé‡è¤‡é™¤å»å¾Œï¼‰: ${filteredData.nodes.length}`);
            
            
            
            // è¾ºã®é•·ã•å‡ç­‰åŒ–ã‚·ã‚¹ãƒ†ãƒ 
            let IDEAL_EDGE_LENGTH = 120;  // ç†æƒ³çš„ãªè¾ºã®é•·ã•ï¼ˆ1.5å€ï¼‰
            const centerX = width / 2;
            const centerY = height / 2;
            
            // åˆæœŸé…ç½®: å…¨ãƒãƒ¼ãƒ‰ã‚’ä¸­å¿ƒä»˜è¿‘ã«ãƒ©ãƒ³ãƒ€ãƒ é…ç½®
            filteredData.nodes.forEach(d => {
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * Math.min(width, height) * 0.3;
                d.x = centerX + r * Math.cos(angle);
                d.y = centerY + r * Math.sin(angle);
            });
            
            // è¾ºã®é•·ã•å‡ç­‰åŒ–ã¨ã‚³ãƒªã‚¸ãƒ§ãƒ³ã®ãƒãƒ©ãƒ³ã‚¹ã‚’å–ã£ãŸã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
            simulation = d3.forceSimulation(filteredData.nodes)
                .force('link', d3.forceLink(filteredData.edges)
                    .id(d => d.id)
                    .distance(IDEAL_EDGE_LENGTH)  // ç†æƒ³çš„ãªè¾ºã®é•·ã•
                    .strength(0.8))  // æŸ”è»Ÿæ€§ã‚’æŒãŸã›ã¦Â±10%ç¨‹åº¦ã®èª¤å·®ã‚’è¨±å®¹
                .force('charge', d3.forceManyBody()
                    .strength(-300)  // é©åº¦ãªæ–¥åŠ›
                    .distanceMax(IDEAL_EDGE_LENGTH * 2))  // å½±éŸ¿ç¯„å›²ã‚’åˆ¶é™
                .force('center', d3.forceCenter(width / 2, height / 2).strength(0.1))
                .force('collision', d3.forceCollide()
                    .radius(d => getNodeRadius(d) * 1.05)  // å®Ÿéš›ã®ã‚µã‚¤ã‚ºã‚ˆã‚Šå°‘ã—å¤§ãã‚
                    .strength(0.9)  // å¼·ã„è¡çªå›é¿
                    .iterations(3))  // ç²¾åº¦å‘ä¸Šã®ãŸã‚åå¾©å›æ•°å¢—åŠ 
                .alphaDecay(0.005)  // ã‚†ã£ãã‚ŠåæŸã§å®‰å®šåŒ–
                .velocityDecay(0.2);  // ä½ã„é€Ÿåº¦æ¸›è¡°ã§è‡ªç„¶ãªå‹•ã
            
            // 15ç§’å¾Œã«è‡ªå‹•çš„ã«ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’åœæ­¢
            setTimeout(() => {
                if (simulation) simulation.stop();
            }, 15000);
            
            // ã‚¨ãƒƒã‚¸ã‚’æç”»
            const linkGroup = g.append('g').attr('class', 'links');
            links = linkGroup.selectAll('line')
                .data(filteredData.edges)
                .join('line')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 1)
                .attr('marker-end', 'url(#arrowhead)');
            
            // åˆæœŸè¾ºã®è‰²ã‚’è¨­å®š
            setTimeout(updateEdgeColors, 100);
            
            // çŸ¢å°ãƒãƒ¼ã‚«ãƒ¼ã¨ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å®šç¾©
            const defs = svg.append('defs');
            
            // çŸ¢å°ãƒãƒ¼ã‚«ãƒ¼
            defs.append('marker')
                .attr('id', 'arrowhead')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 8)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', '#ccc');
            
            // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ç”¨radialGradientã‚’ä½œæˆ
            function createHeatmapGradients() {
                Object.keys(heatmapColors).forEach(type => {
                    const gradient = defs.append('radialGradient')
                        .attr('id', `heatmap-gradient-${type}`)
                        .attr('cx', '50%')
                        .attr('cy', '50%')
                        .attr('r', '50%');
                    
                    // ä¸­å¿ƒã¯æŒ‡å®šè‰²ã€å¤–å´ã¯é€æ˜
                    gradient.append('stop')
                        .attr('offset', '0%')
                        .attr('stop-color', heatmapColors[type])
                        .attr('stop-opacity', heatmapOpacity);
                    
                    gradient.append('stop')
                        .attr('offset', '100%')
                        .attr('stop-color', heatmapColors[type])
                        .attr('stop-opacity', 0);
                });
            }
            
            createHeatmapGradients();
            
            // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚¢ã‚¤ãƒ†ãƒ ã‚¿ã‚¤ãƒ—åˆ¥ã«ä½œæˆï¼ˆãƒãƒ¼ãƒ‰ã‚ˆã‚Šä¸‹ã«é…ç½®ï¼‰
            heatmapGroup = g.append('g').attr('class', 'heatmap-layer');
            
            // ã‚¢ã‚¤ãƒ†ãƒ ã‚¿ã‚¤ãƒ—åˆ¥ã®ã‚µãƒ–ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
            heatmapLayers = {};
            Object.keys(heatmapColors).forEach(type => {
                heatmapLayers[type] = heatmapGroup.append('g')
                    .attr('class', `heatmap-${type}`)
                    .style('mix-blend-mode', 'multiply'); // åŒã˜è‰²åŒå£«ã¯æ¿ƒããªã‚‹
            });
            
            // å…¨ä½“ã®ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã‚°ãƒ«ãƒ¼ãƒ—ã«ç•°ãªã‚‹è‰²åŒå£«ã®åŠ¹æœã‚’é©ç”¨
            heatmapGroup.style('mix-blend-mode', 'screen'); // ç•°ãªã‚‹è‰²åŒå£«ã¯ç™½ã£ã½ããªã‚‹
            
            // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—å††ã‚’ä½œæˆãƒ»æ›´æ–°ã™ã‚‹é–¢æ•°
            function updateHeatmap() {
                if (!heatmapEnabled) {
                    Object.values(heatmapLayers).forEach(layer => {
                        layer.selectAll('.heatmap-circle').remove();
                    });
                    return;
                }
                
                // ã‚¢ã‚¤ãƒ†ãƒ ã‚¿ã‚¤ãƒ—åˆ¥ã«ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†ã‘ã‚‹
                const nodesByType = {};
                Object.keys(heatmapColors).forEach(type => {
                    nodesByType[type] = filteredData.nodes.filter(d => getItemType(d) === type);
                });
                
                // å„ã‚¿ã‚¤ãƒ—åˆ¥ã«ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—å††ã‚’æç”»
                Object.keys(nodesByType).forEach(type => {
                    const layer = heatmapLayers[type];
                    const heatmapCircles = layer.selectAll('.heatmap-circle')
                        .data(nodesByType[type], d => d.id);
                    
                    heatmapCircles.exit().remove();
                    
                    const heatmapEnter = heatmapCircles.enter()
                        .append('circle')
                        .attr('class', 'heatmap-circle');
                    
                    heatmapCircles.merge(heatmapEnter)
                        .attr('r', d => getHeatmapRadius(d.price))  // ä¾¡æ ¼ãƒ™ãƒ¼ã‚¹ã®åŠå¾„
                        .attr('fill', `url(#heatmap-gradient-${type})`)
                        .attr('cx', d => d.x || 0)
                        .attr('cy', d => d.y || 0);
                });
            }
            
            // ãƒãƒ¼ãƒ‰ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
            const nodeGroup = g.append('g').attr('class', 'nodes');
            
            // ãƒãƒ¼ãƒ‰ã‚’æç”»
            nodes = nodeGroup.selectAll('.node')
                .data(filteredData.nodes)
                .join('g')
                .attr('class', 'node')
                .attr('transform', d => `translate(${d.x},${d.y})`)  // åˆæœŸä½ç½®ã‚’è¨­å®š
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // ãƒ›ãƒãƒ¼åˆ¤å®šç”¨ã®é€æ˜ãªå¤§ããªå††ï¼ˆãƒãƒ¼ãƒ‰ã‚µã‚¤ã‚ºã®1.5å€ï¼‰
            nodes.append('circle')
                .attr('class', 'hover-area')
                .attr('r', d => getNodeRadius(d) * 1.5)
                .attr('fill', 'transparent')
                .attr('stroke', 'none')
                .style('cursor', 'pointer');
            
            // ãƒãƒ¼ãƒ‰ã®ãƒ•ãƒ¬ãƒ¼ãƒ ï¼ˆå††ï¼‰
            nodes.append('circle')
                .attr('r', d => getNodeRadius(d))
                .attr('fill', 'none')
                .attr('stroke', d => getNodeColor(d).stroke)
                .attr('stroke-width', d => d.category === 'legendary' ? 4 : 3)
                .style('pointer-events', 'none');
            
            // ã‚¢ã‚¤ãƒ†ãƒ ç”»åƒ
            nodes.append('image')
                .attr('href', d => `https://ddragon.leagueoflegends.com/cdn/{{ patch_version }}/img/item/${d.itemId}.png`)
                .attr('width', d => getNodeRadius(d) * 2)
                .attr('height', d => getNodeRadius(d) * 2)
                .attr('x', d => -getNodeRadius(d))
                .attr('y', d => -getNodeRadius(d))
                .style('clip-path', d => `circle(${getNodeRadius(d) - 2}px)`)
                .style('pointer-events', 'none');
            
            // ãƒ†ã‚­ã‚¹ãƒˆãƒ©ãƒ™ãƒ«ã‚’å‰Šé™¤ï¼ˆç”»åƒã®ã¿ã§è¡¨ç¤ºï¼‰
            
            // å›ºå®šæƒ…å ±ãƒ‘ãƒãƒ«ã®å®Ÿè£…ï¼ˆã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°ã«å¤‰æ›´ï¼‰
            window.infoPanel = d3.select('#info-panel');
            window.panelTitle = d3.select('#panel-title');
            window.panelContent = d3.select('#panel-content');
            
            // ãƒ‡ãƒãƒƒã‚°: ãƒ‘ãƒãƒ«è¦ç´ ã®å­˜åœ¨ç¢ºèª
            console.log('infoPanel element found:', !window.infoPanel.empty());
            console.log('panelTitle element found:', !window.panelTitle.empty());
            console.log('panelContent element found:', !window.panelContent.empty());
            
            // æ·±ã•åˆ¥ã‚¨ãƒƒã‚¸ãƒã‚¤ãƒ©ã‚¤ãƒˆæ©Ÿèƒ½
            function highlightConnectedEdges(hoveredNode) {
                // BFS ã§æ·±ã•1ã€2ã®æ¥ç¶šã‚’æ¢ç´¢
                const depth1 = new Set();
                const depth2 = new Set();
                
                // æ·±ã•1ã®æ¥ç¶šã‚’æ¢ç´¢
                filteredData.edges.forEach(edge => {
                    if (edge.source.id === hoveredNode.id) {
                        depth1.add(edge.target.id);
                    } else if (edge.target.id === hoveredNode.id) {
                        depth1.add(edge.source.id);
                    }
                });
                
                // æ·±ã•2ã®æ¥ç¶šã‚’æ¢ç´¢
                depth1.forEach(nodeId => {
                    filteredData.edges.forEach(edge => {
                        if (edge.source.id === nodeId && edge.target.id !== hoveredNode.id && !depth1.has(edge.target.id)) {
                            depth2.add(edge.target.id);
                        } else if (edge.target.id === nodeId && edge.source.id !== hoveredNode.id && !depth1.has(edge.source.id)) {
                            depth2.add(edge.source.id);
                        }
                    });
                });
                
                // é–¢é€£ãƒãƒ¼ãƒ‰ã‚’åé›†ï¼ˆãƒ›ãƒãƒ¼å¯¾è±¡ + æ·±ã•1 + æ·±ã•2ï¼‰
                const relatedNodes = new Set([hoveredNode.id, ...depth1, ...depth2]);
                
                // é–¢é€£ãƒãƒ¼ãƒ‰ã‚’æœ€å‰é¢ã«ç§»å‹•
                nodes.each(function(d) {
                    if (relatedNodes.has(d.id)) {
                        d3.select(this).raise();
                    }
                });
                
                // ãƒãƒ¼ãƒ‰ã®è¦‹ãŸç›®ã‚’æ›´æ–°ï¼ˆé–¢é€£ãƒãƒ¼ãƒ‰ã¯é€šå¸¸ã€ãã®ä»–ã¯å°‘ã—æš—ãï¼‰
                nodes.select('circle')
                    .attr('opacity', d => relatedNodes.has(d.id) ? 1.0 : 0.6);
                
                nodes.select('image')
                    .attr('opacity', d => relatedNodes.has(d.id) ? 1.0 : 0.5);
                
                // ã‚¨ãƒƒã‚¸ã®è‰²ã¨ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ›´æ–°
                links.attr('stroke', d => {
                    const sourceId = d.source.id;
                    const targetId = d.target.id;
                    
                    // æ·±ã•1ã®æ¥ç¶š
                    if ((sourceId === hoveredNode.id && depth1.has(targetId)) || 
                        (targetId === hoveredNode.id && depth1.has(sourceId))) {
                        return '#ff4444';  // èµ¤
                    }
                    // æ·±ã•2ã®æ¥ç¶š
                    else if ((depth1.has(sourceId) && depth2.has(targetId)) || 
                             (depth1.has(targetId) && depth2.has(sourceId))) {
                        return '#ff8800';  // ã‚ªãƒ¬ãƒ³ã‚¸
                    }
                    // ãã®ä»–
                    else {
                        return '#ddd';  // è–„ã„ç°è‰²
                    }
                })
                .attr('stroke-width', d => {
                    const sourceId = d.source.id;
                    const targetId = d.target.id;
                    
                    // æ·±ã•1ã®æ¥ç¶š
                    if ((sourceId === hoveredNode.id && depth1.has(targetId)) || 
                        (targetId === hoveredNode.id && depth1.has(sourceId))) {
                        return 4;  // å¤ªã„
                    }
                    // æ·±ã•2ã®æ¥ç¶š
                    else if ((depth1.has(sourceId) && depth2.has(targetId)) || 
                             (depth1.has(targetId) && depth2.has(sourceId))) {
                        return 2;  // ä¸­ç¨‹åº¦
                    }
                    // ãã®ä»–
                    else {
                        return 1;  // ç´°ã„
                    }
                })
                .attr('opacity', d => {
                    const sourceId = d.source.id;
                    const targetId = d.target.id;
                    
                    // æ·±ã•1ã€2ã®æ¥ç¶š
                    if ((sourceId === hoveredNode.id && depth1.has(targetId)) || 
                        (targetId === hoveredNode.id && depth1.has(sourceId)) ||
                        (depth1.has(sourceId) && depth2.has(targetId)) || 
                        (depth1.has(targetId) && depth2.has(sourceId))) {
                        return 1.0;  // å®Œå…¨ã«è¡¨ç¤º
                    }
                    // ãã®ä»–
                    else {
                        return 0.3;  // åŠé€æ˜
                    }
                });
                
                // ãƒãƒ¼ãƒ‰ã®å¼·èª¿
                nodes.select('circle').attr('stroke-width', d => {
                    if (d.id === hoveredNode.id) {
                        return 6;  // é¸æŠã•ã‚ŒãŸãƒãƒ¼ãƒ‰
                    } else if (depth1.has(d.id)) {
                        return 4;  // æ·±ã•1ã®ãƒãƒ¼ãƒ‰
                    } else if (depth2.has(d.id)) {
                        return 3;  // æ·±ã•2ã®ãƒãƒ¼ãƒ‰
                    } else {
                        return d.category === 'legendary' ? 4 : 3;  // é€šå¸¸
                    }
                })
                .attr('opacity', d => {
                    if (d.id === hoveredNode.id || depth1.has(d.id) || depth2.has(d.id)) {
                        return 1.0;  // å®Œå…¨ã«è¡¨ç¤º
                    } else {
                        return 0.5;  // åŠé€æ˜
                    }
                });
            }
            
            function resetHighlight() {
                // ã‚¨ãƒƒã‚¸ã‚’é€šå¸¸ã«æˆ»ã™
                links.attr('stroke', '#ccc')
                     .attr('stroke-width', 1)
                     .attr('opacity', 1.0);
                
                // ãƒãƒ¼ãƒ‰ã‚’é€šå¸¸ã«æˆ»ã™
                nodes.select('circle')
                     .attr('stroke-width', d => d.category === 'legendary' ? 4 : 3)
                     .attr('opacity', 1.0);
                
                nodes.select('image')
                     .attr('opacity', 1.0);
            }
            
            nodes.on('mouseover', function(event, d) {
                console.log('Node mouseover event fired for:', d.label);
                highlightConnectedEdges(d);
                showInfoPanel(d);
            })
            .on('mouseout', function(event, d) {
                resetHighlight();
                hideInfoPanel();
            });
            
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã®æ›´æ–°å‡¦ç†
            simulation.on('tick', () => {
                links
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                nodes
                    .attr('transform', d => `translate(${d.x},${d.y})`);
                
                // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã®ä½ç½®ã‚‚æ›´æ–°
                if (heatmapEnabled) {
                    Object.values(heatmapLayers).forEach(layer => {
                        layer.selectAll('.heatmap-circle')
                            .attr('cx', d => d.x)
                            .attr('cy', d => d.y);
                    });
                }
            });
            
            // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã®åˆæœŸåŒ–ï¼ˆã™ã¹ã¦ã®è¦ç´ ãŒä½œæˆã•ã‚ŒãŸå¾Œï¼‰
            updateHeatmap();
        }
        
        // ç¾åœ¨ã®åŠå¾„é–¢æ•°ã‚¿ã‚¤ãƒ—
        let currentRadiusFunction = 'logarithmic';
        
        // ä¾¡æ ¼ãƒ™ãƒ¼ã‚¹ã®åŠå¾„è¨ˆç®—é–¢æ•°ï¼ˆé–¢æ•°ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦åˆ‡ã‚Šæ›¿ãˆï¼‰
        function getPriceBasedRadius(price, minRadius = 8, maxRadius = 35) {
            const minPrice = 0;
            const maxPrice = 3500;
            
            // ä¾¡æ ¼ãŒ0ã®å ´åˆã¯æœ€å°åŠå¾„
            if (price <= 0) return minRadius;
            
            const ratio = Math.min(price / maxPrice, 1);
            let scaledRatio;
            
            switch(currentRadiusFunction) {
                case 'logarithmic':
                    // å¯¾æ•°é–¢æ•°ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
                    scaledRatio = Math.log(1 + ratio * 9) / Math.log(10);
                    break;
                case 'exponential':
                    // æŒ‡æ•°é–¢æ•°ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°ï¼ˆx^2ï¼‰
                    scaledRatio = Math.pow(ratio, 2);
                    break;
                case 'linear':
                    // ç·šå½¢ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
                    scaledRatio = ratio;
                    break;
                case 'sqrt':
                    // ãƒ«ãƒ¼ãƒˆé–¢æ•°ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
                    scaledRatio = Math.sqrt(ratio);
                    break;
                default:
                    scaledRatio = ratio;
            }
            
            return minRadius + (maxRadius - minRadius) * scaledRatio;
        }
        
        // åŠå¾„é–¢æ•°å¤‰æ›´æ™‚ã®å‡¦ç†
        function updateRadiusFunction() {
            currentRadiusFunction = document.getElementById('radius-function').value;
            console.log('åŠå¾„é–¢æ•°ã‚’å¤‰æ›´:', currentRadiusFunction);
            
            // ãƒãƒ¼ãƒ‰ã®åŠå¾„ã‚’æ›´æ–°
            if (typeof svg !== 'undefined' && svg && typeof nodes !== 'undefined' && nodes) {
                // é€šå¸¸ã®ãƒãƒ¼ãƒ‰åŠå¾„æ›´æ–°
                svg.selectAll('.node circle')
                    .transition()
                    .duration(500)
                    .attr('r', d => getNodeRadius(d));
                
                // è¡çªæ¤œçŸ¥ã®åŠå¾„ã‚‚æ›´æ–°
                if (typeof simulation !== 'undefined' && simulation) {
                    simulation.force('collision')
                        .radius(d => getNodeRadius(d) * 1.05);
                    simulation.alpha(0.3).restart();
                }
                    
                // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã‚‚æ›´æ–°
                updateHeatmap();
                
                console.log('åŠå¾„é–¢æ•°æ›´æ–°å®Œäº†');
            } else {
                console.warn('ã‚°ãƒ©ãƒ•ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
            }
        }
        
        function getNodeRadius(d) {
            return getPriceBasedRadius(d.price || 0) * nodeRadiusMultiplier;
        }
        
        // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ç”¨ã®åŠå¾„è¨ˆç®—ï¼ˆãƒãƒ¼ãƒ‰åŠå¾„ã®4å€ï¼‰
        function getHeatmapRadius(price) {
            const nodeRadius = getPriceBasedRadius(price || 0);
            return nodeRadius * 4.0 * heatmapRadiusMultiplier; // ãƒãƒ¼ãƒ‰åŠå¾„ã®4å€ Ã— å€ç‡
        }
        
        function getNodeColor(d) {
            switch(d.category) {
                case 'basic': return { stroke: '#28a745' };
                case 'intermediate': return { stroke: '#007bff' };
                case 'legendary': return { stroke: '#ffc107' };
                default: return { stroke: '#6c757d' };
            }
        }
        
        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        
        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }
        
        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            // è¾ºã®é•·ã•å‡ç­‰åŒ–ã§ã¯å…¨ãƒãƒ¼ãƒ‰ã‚’è‡ªç”±ã«é…ç½®
            d.fx = null;
            d.fy = null;
        }
        
        
        function applyPriceFilter() {
            const minPrice = parseInt(document.getElementById('min-price').value);
            const maxPrice = parseInt(document.getElementById('max-price').value);
            
            if (!fullGraphData || !nodes) return;
            
            // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã•ã‚ŒãŸãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
            const filteredNodes = fullGraphData.nodes.filter(d => d.price >= minPrice && d.price <= maxPrice);
            const filteredNodeIds = new Set(filteredNodes.map(d => d.id));
            const filteredEdges = fullGraphData.edges.filter(d => 
                filteredNodeIds.has(d.source) && filteredNodeIds.has(d.target)
            );
            
            // optimalBasicOrderã‚’é–¢æ•°å†…ã§å®šç¾©ï¼ˆã‚°ãƒ«ãƒ¼ãƒ—ãƒ™ãƒ¼ã‚¹ç·å½“ãŸã‚Šæœ€é©åŒ–ï¼‰
            const optimalBasicOrder = [
                "1052", "1027", "1004", "1026", "1058", "3070", "1042",
                "1018", "1038", "1036", "1037", "1006", "1028", "1033",
                "1029", "2022"
            ];
            
            // ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°ï¼ˆé‡è¤‡é™¤å»ï¼‰
            const uniqueFilteredNodes = new Map();
            filteredNodes.forEach(node => {
                if (!uniqueFilteredNodes.has(node.id)) {
                    uniqueFilteredNodes.set(node.id, {...node});
                } else {
                    console.warn(`ãƒ•ã‚£ãƒ«ã‚¿å¾Œé‡è¤‡ãƒãƒ¼ãƒ‰æ¤œå‡º: ${node.label} (ID: ${node.id})`);
                }
            });
            
            filteredData.nodes = Array.from(uniqueFilteredNodes.values());
            filteredData.edges = filteredEdges.map(d => ({...d}));
            
            console.log(`ãƒ•ã‚£ãƒ«ã‚¿å¾Œãƒãƒ¼ãƒ‰æ•°ï¼ˆé‡è¤‡é™¤å»å¾Œï¼‰: ${filteredData.nodes.length}`);
            
            // è¾ºã®é•·ã•å‡ç­‰åŒ–ã®ãŸã‚ã€ãƒ•ã‚£ãƒ«ã‚¿å¾Œã‚‚åˆæœŸé…ç½®ã‚’å†å®Ÿè¡Œ
            const container = document.getElementById('d3-full-graph');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            const IDEAL_EDGE_LENGTH = 120;
            
            // å…¨ãƒãƒ¼ãƒ‰ã‚’ä¸­å¿ƒä»˜è¿‘ã«ãƒ©ãƒ³ãƒ€ãƒ é…ç½®
            filteredData.nodes.forEach(d => {
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * Math.min(width, height) * 0.3;
                d.x = centerX + r * Math.cos(angle);
                d.y = centerY + r * Math.sin(angle);
            });
            
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†åˆæœŸåŒ–
            simulation.nodes(filteredData.nodes);
            simulation.force('link').links(filteredData.edges);
            
            // DOMã‚’æ›´æ–°
            links = links.data(filteredData.edges, d => d.source.id + '-' + d.target.id);
            links.exit().remove();
            links = links.enter().append('line')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 1)
                .attr('marker-end', 'url(#arrowhead)')
                .merge(links);
            
            nodes = nodes.data(filteredData.nodes, d => d.id);
            nodes.exit().remove();
            const nodeEnter = nodes.enter().append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            // ãƒ›ãƒãƒ¼åˆ¤å®šç”¨ã®é€æ˜ãªå¤§ããªå††
            nodeEnter.append('circle')
                .attr('class', 'hover-area')
                .attr('r', d => getNodeRadius(d) * 1.5)
                .attr('fill', 'transparent')
                .attr('stroke', 'none')
                .style('cursor', 'pointer');
            
            nodeEnter.append('circle')
                .attr('r', d => getNodeRadius(d))
                .attr('fill', 'none')
                .attr('stroke', d => getNodeColor(d).stroke)
                .attr('stroke-width', d => d.category === 'legendary' ? 4 : 3)
                .style('pointer-events', 'none');
            
            nodeEnter.append('image')
                .attr('href', d => `https://ddragon.leagueoflegends.com/cdn/{{ patch_version }}/img/item/${d.itemId}.png`)
                .attr('width', d => getNodeRadius(d) * 2)
                .attr('height', d => getNodeRadius(d) * 2)
                .attr('x', d => -getNodeRadius(d))
                .attr('y', d => -getNodeRadius(d))
                .style('clip-path', d => `circle(${getNodeRadius(d) - 2}px)`)
                .style('pointer-events', 'none');
            
            // ãƒ†ã‚­ã‚¹ãƒˆãƒ©ãƒ™ãƒ«ã‚’å‰Šé™¤ï¼ˆç”»åƒã®ã¿ã§è¡¨ç¤ºï¼‰
            
            nodes = nodeEnter.merge(nodes);
            
            // ãƒ›ãƒãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆã‚’å†è¨­å®š
            nodes.on('mouseover', function(event, d) {
                console.log('Node mouseover event fired for:', d.label);
                highlightConnectedEdges(d);
                showInfoPanel(d);
            })
            .on('mouseout', function(event, d) {
                resetHighlight();
                hideInfoPanel();
            });
            
            // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã‚’æ›´æ–°
            if (typeof updateHeatmap === 'function') {
                updateHeatmap();
            }
            
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†é–‹
            simulation.alpha(1).restart();
        }
        
        function clearFilter() {
            document.getElementById('min-price').value = 0;
            document.getElementById('max-price').value = 5000;
            document.getElementById('min-price-value').textContent = '0G';
            document.getElementById('max-price-value').textContent = '5000G';
            
            applyPriceFilter();
        }
        
        function resetLayout() {
            if (!simulation) return;
            
            const container = document.getElementById('d3-full-graph');
            const width = container.clientWidth;
            const height = container.clientHeight;
            const centerX = width / 2;
            const centerY = height / 2;
            
            // å…¨ãƒãƒ¼ãƒ‰ã®å›ºå®šã‚’è§£é™¤
            filteredData.nodes.forEach(d => {
                d.fx = null;
                d.fy = null;
                
                // æ–°ã—ã„ãƒ©ãƒ³ãƒ€ãƒ é…ç½®
                const angle = Math.random() * 2 * Math.PI;
                const r = Math.random() * Math.min(width, height) * 0.3;
                d.x = centerX + r * Math.cos(angle);
                d.y = centerY + r * Math.sin(angle);
            });
            
            // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã‚’æ›´æ–°
            if (typeof updateHeatmap === 'function') {
                updateHeatmap();
            }
            
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’å†é–‹
            simulation.alpha(1).restart();
            
            // 15ç§’å¾Œã«è‡ªå‹•åœæ­¢
            setTimeout(() => {
                if (simulation) simulation.stop();
            }, 15000);
        }
        
        function zoomToFit() {
            if (!svg || !g) return;
            
            const bounds = g.node().getBBox();
            const parent = svg.node().parentElement;
            const fullWidth = parent.clientWidth;
            const fullHeight = parent.clientHeight;
            
            const width = bounds.width;
            const height = bounds.height;
            
            const midX = bounds.x + width / 2;
            const midY = bounds.y + height / 2;
            
            if (width == 0 || height == 0) return;
            
            const scale = 0.8 / Math.max(width / fullWidth, height / fullHeight);
            const translate = [fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY];
            
            svg.transition()
                .duration(750)
                .call(d3.zoom().transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
        }
        
        // è¾ºã®é•·ã•ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        const edgeLengthSlider = document.getElementById('edge-length-slider');
        const edgeLengthValue = document.getElementById('edge-length-value');
        
        edgeLengthSlider.addEventListener('input', function(e) {
            IDEAL_EDGE_LENGTH = parseInt(e.target.value);
            edgeLengthValue.textContent = IDEAL_EDGE_LENGTH + 'px';
            
            // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æ›´æ–°
            if (simulation) {
                simulation.force('link')
                    .distance(IDEAL_EDGE_LENGTH)
                    .strength(0.8);  // æŸ”è»Ÿæ€§ã‚’ä¿æŒ
                
                simulation.force('charge')
                    .strength(-300)
                    .distanceMax(IDEAL_EDGE_LENGTH * 2);
                
                simulation.force('collision')
                    .radius(d => getNodeRadius(d) * 1.05)
                    .strength(0.9);
                
                simulation.alpha(0.5).restart();
            }
        });
        
        function resetEdgeLength() {
            edgeLengthSlider.value = 120;
            edgeLengthValue.textContent = '120px';
            IDEAL_EDGE_LENGTH = 120;
            
            if (simulation) {
                simulation.force('link')
                    .distance(IDEAL_EDGE_LENGTH)
                    .strength(0.8);  // æŸ”è»Ÿæ€§ã‚’ä¿æŒ
                
                simulation.force('charge')
                    .strength(-300)
                    .distanceMax(IDEAL_EDGE_LENGTH * 2);
                
                simulation.force('collision')
                    .radius(d => getNodeRadius(d) * 1.05)
                    .strength(0.9);
                
                simulation.alpha(0.5).restart();
            }
        }
        
        // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«æ©Ÿèƒ½
        const heatmapToggle = document.getElementById('heatmap-toggle');
        const heatmapOpacitySlider = document.getElementById('heatmap-opacity-slider');
        const heatmapOpacityValue = document.getElementById('heatmap-opacity-value');
        
        // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—ãƒˆã‚°ãƒ«æ©Ÿèƒ½
        function toggleHeatmap() {
            heatmapEnabled = !heatmapEnabled;
            heatmapToggle.classList.toggle('active', heatmapEnabled);
            heatmapToggle.textContent = heatmapEnabled ? 'ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ— ON' : 'ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ— OFF';
            
            if (typeof updateHeatmap === 'function') {
                updateHeatmap();
            }
            
            // è¾ºã®è‰²ã‚’é€£å‹•æ›´æ–°
            updateEdgeColors();
        }
        
        
        // é€æ˜åº¦ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
        heatmapOpacitySlider.addEventListener('input', function(e) {
            heatmapOpacity = parseInt(e.target.value) / 100; // ãƒ‘ãƒ¼ã‚»ãƒ³ãƒˆã‚’å°æ•°ã«å¤‰æ›
            heatmapOpacityValue.textContent = e.target.value + '%';
            
            // ç›´æ¥ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã®é€æ˜åº¦ã‚’æ›´æ–°ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—å•é¡Œã‚’å›é¿ï¼‰
            if (svg) {
                svg.selectAll('radialGradient[id^="heatmap-gradient-"] stop[offset="0%"]')
                   .attr('stop-opacity', heatmapOpacity);
                
                console.log('ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—é€æ˜åº¦ã‚’æ›´æ–°:', heatmapOpacity);
            }
            
            // è¾ºã®è‰²ã‚‚æ›´æ–°ï¼ˆé€æ˜åº¦å¤‰æ›´æ™‚ã‚‚è¦–èªæ€§ã‚’ä¿ã¤ï¼‰
            updateEdgeColors();
        });
        
        function pauseSimulation() {
            if (!simulation) return;
            
            if (isPaused) {
                simulation.restart();
                isPaused = false;
            } else {
                simulation.stop();
                isPaused = true;
            }
        }
        
        function showInfoPanel(d) {
            console.log('showInfoPanel called for:', d.label);
            console.log('window.infoPanel exists:', !!window.infoPanel);
            console.log('infoPanel is empty:', window.infoPanel ? window.infoPanel.empty() : 'undefined');
            
            // ãƒ‘ãƒãƒ«è¦ç´ ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
            if (!window.infoPanel || window.infoPanel.empty()) {
                console.error('infoPanel not found or empty');
                // ç›´æ¥DOMã§è¦ç´ ã‚’æ¢ã—ã¦ã¿ã‚‹
                const directElement = document.getElementById('info-panel');
                console.log('Direct DOM element found:', !!directElement);
                if (directElement) {
                    console.log('Direct element display style:', directElement.style.display);
                    console.log('Direct element computed style:', getComputedStyle(directElement).display);
                }
                return;
            }
            
            // BFS ã§æ·±ã•1ã€2ã®æ¥ç¶šã‚’æ¢ç´¢ï¼ˆæ¥ç¶šæƒ…å ±ç”¨ï¼‰
            const depth1 = new Set();
            const depth2 = new Set();
            
            // æ·±ã•1ã®æ¥ç¶šã‚’æ¢ç´¢
            filteredData.edges.forEach(edge => {
                if (edge.source.id === d.id) {
                    depth1.add(edge.target.id);
                } else if (edge.target.id === d.id) {
                    depth1.add(edge.source.id);
                }
            });
            
            // æ·±ã•2ã®æ¥ç¶šã‚’æ¢ç´¢
            depth1.forEach(nodeId => {
                filteredData.edges.forEach(edge => {
                    if (edge.source.id === nodeId && edge.target.id !== d.id && !depth1.has(edge.target.id)) {
                        depth2.add(edge.target.id);
                    } else if (edge.target.id === nodeId && edge.source.id !== d.id && !depth1.has(edge.source.id)) {
                        depth2.add(edge.source.id);
                    }
                });
            });
            
            // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æƒ…å ±ã‚’æ•´å½¢
            let statsHtml = '';
            if (d.stats && Object.keys(d.stats).length > 0) {
                statsHtml = '<div class="item-stats">';
                for (const [stat, value] of Object.entries(d.stats)) {
                    const statName = getStatName(stat);
                    if (statName && value !== 0) {
                        const displayValue = value > 0 ? `+${value}` : `${value}`;
                        statsHtml += `<div class="stat-line">${displayValue} ${statName}</div>`;
                    }
                }
                statsHtml += '</div>';
            }
            
            // æ¥ç¶šæƒ…å ±ã‚’æ•´å½¢
            let connectionHtml = '';
            if (depth1.size > 0 || depth2.size > 0) {
                connectionHtml = '<div class="connection-info">';
                if (depth1.size > 0) {
                    connectionHtml += `<h4>ç›´æ¥æ¥ç¶š <span class="depth-1">(${depth1.size}å€‹)</span></h4>`;
                }
                if (depth2.size > 0) {
                    connectionHtml += `<h4>2æ®µéšæ¥ç¶š <span class="depth-2">(${depth2.size}å€‹)</span></h4>`;
                }
                connectionHtml += '</div>';
            }
            
            // ãƒ‘ãƒãƒ«ã®å†…å®¹ã‚’æ›´æ–°
            window.panelTitle.text(d.label);
            window.panelContent.html(`
                <div class="item-price">${d.price}G</div>
                ${d.description ? `<div class="item-description">${d.description}</div>` : ''}
                ${statsHtml}
                ${connectionHtml}
            `);
            
            // ãƒ‘ãƒãƒ«ã‚’è¡¨ç¤º
            console.log('About to display panel...');
            window.infoPanel.style('display', 'block');
            console.log('InfoPanel display style set to block');
            
            // è¡¨ç¤ºãŒæ­£ã—ãé©ç”¨ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
            const actualElement = document.getElementById('info-panel');
            if (actualElement) {
                console.log('Actual element display after setting:', getComputedStyle(actualElement).display);
                console.log('Actual element visible:', actualElement.offsetHeight > 0);
            }
        }
        
        function hideInfoPanel() {
            if (window.infoPanel && !window.infoPanel.empty()) {
                window.infoPanel.style('display', 'none');
                console.log('InfoPanel hidden');
            }
        }
        
        function getStatName(stat) {
            const statNames = {
                'FlatHPPoolMod': 'ãƒ˜ãƒ«ã‚¹',
                'FlatMPPoolMod': 'ãƒãƒŠ', 
                'FlatArmorMod': 'ç‰©ç†é˜²å¾¡',
                'FlatSpellBlockMod': 'é­”æ³•é˜²å¾¡',
                'FlatPhysicalDamageMod': 'æ”»æ’ƒåŠ›',
                'FlatMagicDamageMod': 'AP',
                'PercentAttackSpeedMod': 'æ”»æ’ƒé€Ÿåº¦',
                'PercentMovementSpeedMod': 'ç§»å‹•é€Ÿåº¦',
                'FlatCritChanceMod': 'ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ç‡',
                'FlatCritDamageMod': 'ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ€ãƒ¡ãƒ¼ã‚¸',
                'PercentLifeStealMod': 'ãƒ©ã‚¤ãƒ•ã‚¹ãƒ†ã‚£ãƒ¼ãƒ«',
                'PercentSpellVampMod': 'ã‚¹ãƒšãƒ«ãƒ´ã‚¡ãƒ³ãƒ—',
                'FlatHPRegenMod': 'ãƒ˜ãƒ«ã‚¹å›å¾©',
                'FlatMPRegenMod': 'ãƒãƒŠå›å¾©',
                'PercentHPRegenMod': 'ãƒ˜ãƒ«ã‚¹å›å¾©%',
                'PercentMPRegenMod': 'ãƒãƒŠå›å¾©%'
            };
            return statNames[stat] || stat;
        }
        
        // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿
        // åŠå¾„èª¿æ•´ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®åˆæœŸåŒ–
        function initializeRadiusControls() {
            const nodeRadiusSlider = document.getElementById('node-radius-multiplier');
            const heatmapRadiusSlider = document.getElementById('heatmap-radius-multiplier');
            const nodeRadiusValue = document.getElementById('node-radius-value');
            const heatmapRadiusValue = document.getElementById('heatmap-radius-value');
            
            // ãƒãƒ¼ãƒ‰åŠå¾„ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            nodeRadiusSlider.addEventListener('input', function() {
                nodeRadiusMultiplier = parseFloat(this.value);
                nodeRadiusValue.textContent = nodeRadiusMultiplier.toFixed(1) + 'x';
                updateNodeRadii();
            });
            
            // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—åŠå¾„ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
            heatmapRadiusSlider.addEventListener('input', function() {
                heatmapRadiusMultiplier = parseFloat(this.value);
                heatmapRadiusValue.textContent = heatmapRadiusMultiplier.toFixed(1) + 'x';
                updateHeatmapRadii();
            });
        }
        
        // ãƒãƒ¼ãƒ‰åŠå¾„ã®ã¿æ›´æ–°
        function updateNodeRadii() {
            if (nodes) {
                // å¤–æ å††ã‚’æ›´æ–°
                nodes.selectAll('circle').attr('r', d => getNodeRadius(d));
                nodes.selectAll('.hover-area').attr('r', d => getNodeRadius(d) * 1.5);
                
                // ç”»åƒã‚µã‚¤ã‚ºãƒ»ä½ç½®ãƒ»ã‚¯ãƒªãƒƒãƒ—ãƒ‘ã‚¹ã‚’æ›´æ–°
                nodes.selectAll('image')
                    .attr('width', d => getNodeRadius(d) * 2)
                    .attr('height', d => getNodeRadius(d) * 2)
                    .attr('x', d => -getNodeRadius(d))
                    .attr('y', d => -getNodeRadius(d))
                    .style('clip-path', d => `circle(${getNodeRadius(d) - 2}px)`);
                
                // force collideã‚‚æ›´æ–°
                if (simulation) {
                    simulation.force('collide').radius(d => getNodeRadius(d) * 1.05);
                    simulation.alpha(0.3).restart();
                }
            }
        }
        
        // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—åŠå¾„ã®ã¿æ›´æ–°
        function updateHeatmapRadii() {
            if (heatmapGroup && heatmapEnabled) {
                heatmapGroup.selectAll('.heatmap-circle')
                    .attr('r', d => getHeatmapRadius(d.price));
            }
        }
        
        // è¾ºã®è‰²ã‚’å‹•çš„ã«æ›´æ–°ï¼ˆã‚·ãƒ³ãƒ—ãƒ«ã«é»’ã§çµ±ä¸€ï¼‰
        function updateEdgeColors() {
            if (!links) return;
            
            let edgeColor = '#000000';  // é»’ã§çµ±ä¸€
            let edgeWidth = 2;
            
            if (heatmapEnabled) {
                edgeWidth = 3; // ãƒ’ãƒ¼ãƒˆãƒãƒƒãƒ—æœ‰åŠ¹æ™‚ã¯å¤ªã
            }
            
            // è¾ºã®è‰²ã¨ã‚¹ã‚¿ã‚¤ãƒ«ã‚’æ›´æ–°
            links.attr('stroke', edgeColor)
                 .attr('stroke-width', edgeWidth)
                 .attr('stroke-opacity', 0.9) // é«˜ã„é€æ˜åº¦ã§è¦–èªæ€§ç¢ºä¿
                 .style('filter', 'drop-shadow(0 0 2px rgba(255,255,255,0.5))'); // ç™½ã„å½±åŠ¹æœ
                 
            console.log('è¾ºã®è‰²ã‚’æ›´æ–°:', edgeColor, 'width:', edgeWidth);
        }
        
        // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã«æˆ»ã™
        function resetRadiusMultipliers() {
            nodeRadiusMultiplier = 1.0;
            heatmapRadiusMultiplier = 1.0;
            
            document.getElementById('node-radius-multiplier').value = 1.0;
            document.getElementById('heatmap-radius-multiplier').value = 1.0;
            document.getElementById('node-radius-value').textContent = '1.0x';
            document.getElementById('heatmap-radius-value').textContent = '1.0x';
            
            updateNodeRadii();
            updateHeatmapRadii();
        }
        
        document.addEventListener('DOMContentLoaded', function() {
            initializeRadiusControls();
            loadGraphData();
        });
    </script>
</body>
</html>